{"version":3,"file":"rapier.es.js","sources":["rapier_wasm3d.js","../gen3d/gen3d/dynamics/rigid_body.ts","../gen3d/gen3d/math.ts","../gen3d/gen3d/dynamics/joint.ts","../gen3d/gen3d/dynamics/rigid_body_set.ts","../gen3d/gen3d/dynamics/integration_parameters.ts","../node_modules/tslib/tslib.es6.js","../gen3d/gen3d/dynamics/coefficient_combine_rule.ts","../gen3d/gen3d/dynamics/joint_set.ts","../gen3d/gen3d/geometry/shape.ts","../gen3d/gen3d/dynamics/ccd_solver.ts","../gen3d/gen3d/dynamics/island_manager.ts","../gen3d/gen3d/geometry/broad_phase.ts","../gen3d/gen3d/geometry/narrow_phase.ts","../gen3d/gen3d/geometry/collider.ts","../gen3d/gen3d/pipeline/event_queue.ts","../gen3d/gen3d/geometry/collider_set.ts","../gen3d/gen3d/geometry/ray.ts","../gen3d/gen3d/geometry/point.ts","../gen3d/gen3d/geometry/toi.ts","../gen3d/gen3d/pipeline/physics_pipeline.ts","../gen3d/gen3d/pipeline/query_pipeline.ts","../gen3d/gen3d/pipeline/serialization_pipeline.ts","../gen3d/gen3d/pipeline/world.ts","../gen3d/gen3d/pipeline/physics_hooks.ts","../node_modules/base64-js/index.js","../gen3d/gen3d/init.ts","../gen3d/gen3d/exports.ts"],"sourcesContent":["\nlet wasm;\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachegetFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachegetFloat32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawJointType = Object.freeze({ Ball:0,\"0\":\"Ball\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Revolute:3,\"3\":\"Revolute\", });\n/**\n*/\nexport const RawSpringModel = Object.freeze({ Disabled:0,\"0\":\"Disabled\",VelocityBased:1,\"1\":\"VelocityBased\",AccelerationBased:2,\"2\":\"AccelerationBased\",ForceBased:3,\"3\":\"ForceBased\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Static:1,\"1\":\"Static\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawbroadphase_new();\n        return RawBroadPhase.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCCDSolver.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawccdsolver_new();\n        return RawCCDSolver.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        var ret = wasm.rawcolliderset_coTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        var ret = wasm.rawcolliderset_coRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        var ret = wasm.rawcolliderset_coIsSensor(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coShapeType(handle) {\n        var ret = wasm.rawcolliderset_coShapeType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        var ret = wasm.rawcolliderset_coHalfExtents(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The radius of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The radius of the round edges of this collider if it is a round cylinder.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        var ret = wasm.rawcolliderset_coHeightfieldScale(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coParent(handle) {\n        var ret = wasm.rawcolliderset_coParent(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        var ret = wasm.rawcolliderset_coFriction(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coDensity(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coDensity(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        var ret = wasm.rawcolliderset_coCollisionGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        var ret = wasm.rawcolliderset_coSolverGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        var ret = wasm.rawcolliderset_coActiveHooks(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        var ret = wasm.rawcolliderset_coActiveCollisionTypes(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        var ret = wasm.rawcolliderset_coActiveEvents(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        var ret = wasm.rawcolliderset_coFrictionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        var ret = wasm.rawcolliderset_coRestitutionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        var ptr0 = shape.ptr;\n        shape.ptr = 0;\n        wasm.rawcolliderset_coSetShape(this.ptr, handle, ptr0);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawcolliderset_new();\n        return RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.rawcolliderset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        var ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {boolean} useMassProps\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(shape, translation, rotation, useMassProps, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.ptr, shape.ptr, translation.ptr, rotation.ptr, useMassProps, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, hasParent, parent, bodies.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.ptr, handle, islands.ptr, bodies.ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        var ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        var ret = wasm.rawcontactmanifold_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        var ret = wasm.rawcontactmanifold_local_n1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        var ret = wasm.rawcontactmanifold_local_n1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        var ret = wasm.rawcontactmanifold_subshape1(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        var ret = wasm.rawcontactmanifold_subshape1(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        var ret = wasm.rawcontactmanifold_num_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        var ret = wasm.rawcontactmanifold_contact_local_p1(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        var ret = wasm.rawcontactmanifold_contact_local_p1(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        var ret = wasm.rawcontactmanifold_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        var ret = wasm.rawcontactmanifold_contact_fid1(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        var ret = wasm.rawcontactmanifold_contact_fid2(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        var ret = wasm.rawcontactmanifold_contact_impulse(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        var ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        var ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        var ret = wasm.rawcontactmanifold_num_solver_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        var ret = wasm.rawcontactmanifold_solver_contact_point(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        var ret = wasm.rawcontactmanifold_solver_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        var ret = wasm.rawcontactmanifold_solver_contact_friction(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        var ret = wasm.rawcontactmanifold_solver_contact_restitution(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        var ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactPair.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        var ret = wasm.rawcontactpair_collider1(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        var ret = wasm.rawcontactpair_collider2(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        var ret = wasm.rawcontactpair_numContactManifolds(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        var ret = wasm.rawcontactpair_contactManifold(this.ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        var ret = wasm.rawdeserializedworld_takeGravity(this.ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        var ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        var ret = wasm.rawdeserializedworld_takeIslandManager(this.ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        var ret = wasm.rawdeserializedworld_takeBroadPhase(this.ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        var ret = wasm.rawdeserializedworld_takeNarrowPhase(this.ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        var ret = wasm.rawdeserializedworld_takeBodies(this.ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        var ret = wasm.rawdeserializedworld_takeColliders(this.ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawJointSet | undefined}\n    */\n    takeJoints() {\n        var ret = wasm.rawdeserializedworld_takeJoints(this.ptr);\n        return ret === 0 ? undefined : RawJointSet.__wrap(ret);\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawEventQueue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        var ret = wasm.raweventqueue_new(autoDrain);\n        return RawEventQueue.__wrap(ret);\n    }\n    /**\n    * Applies the given javascript closure on each contact event of this collector, then clear\n    * the internal contact event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each contact event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the contact, and a boolean indicating if the contact started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainContactEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given javascript closure on each proximity event of this collector, then clear\n    * the internal proximity event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, prev_prox, new_prox)`:  JavaScript closure applied to each proximity event. The\n    * closure should take four arguments: two integers representing the handles of the colliders\n    * involved in the proximity, and one boolean representing the intersection status.\n    * @param {Function} f\n    */\n    drainIntersectionEvents(f) {\n        try {\n            wasm.raweventqueue_drainIntersectionEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.ptr);\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawintegrationparameters_new();\n        return RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        var ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        var ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get jointErp() {\n        var ret = wasm.rawintegrationparameters_jointErp(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get warmstartCoeff() {\n        var ret = wasm.rawintegrationparameters_warmstartCoeff(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        var ret = wasm.rawintegrationparameters_allowedLinearError(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        var ret = wasm.rawintegrationparameters_predictionDistance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedAngularError() {\n        var ret = wasm.rawintegrationparameters_allowedAngularError(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxLinearCorrection() {\n        var ret = wasm.rawintegrationparameters_maxLinearCorrection(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxAngularCorrection() {\n        var ret = wasm.rawintegrationparameters_maxAngularCorrection(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityIterations() {\n        var ret = wasm.rawintegrationparameters_maxVelocityIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxPositionIterations() {\n        var ret = wasm.rawintegrationparameters_maxPositionIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        var ret = wasm.rawintegrationparameters_minIslandSize(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        var ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set jointErp(value) {\n        wasm.rawintegrationparameters_set_jointErp(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set warmstartCoeff(value) {\n        wasm.rawintegrationparameters_set_warmstartCoeff(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedAngularError(value) {\n        wasm.rawintegrationparameters_set_allowedAngularError(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxLinearCorrection(value) {\n        wasm.rawintegrationparameters_set_maxLinearCorrection(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxAngularCorrection(value) {\n        wasm.rawintegrationparameters_set_maxAngularCorrection(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxPositionIterations(value) {\n        wasm.rawintegrationparameters_set_maxPositionIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, value);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawislandmanager_new();\n        return RawIslandManager.__wrap(ret);\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawJointParams {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawJointParams.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawjointparams_free(ptr);\n    }\n    /**\n    * Create a new joint descriptor that builds Ball joints.\n    *\n    * A ball joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawJointParams}\n    */\n    static ball(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        var ret = wasm.rawjointparams_ball(anchor1.ptr, anchor2.ptr);\n        return RawJointParams.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} axis1\n    * @param {RawVector} tangent1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis2\n    * @param {RawVector} tangent2\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawJointParams | undefined}\n    */\n    static prismatic(anchor1, axis1, tangent1, anchor2, axis2, tangent2, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axis1, RawVector);\n        _assertClass(tangent1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis2, RawVector);\n        _assertClass(tangent2, RawVector);\n        var ret = wasm.rawjointparams_prismatic(anchor1.ptr, axis1.ptr, tangent1.ptr, anchor2.ptr, axis2.ptr, tangent2.ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawJointParams.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawJointParams}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        var ret = wasm.rawjointparams_fixed(anchor1.ptr, axes1.ptr, anchor2.ptr, axes2.ptr);\n        return RawJointParams.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} axis1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis2\n    * @returns {RawJointParams | undefined}\n    */\n    static revolute(anchor1, axis1, anchor2, axis2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axis1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis2, RawVector);\n        var ret = wasm.rawjointparams_revolute(anchor1.ptr, axis1.ptr, anchor2.ptr, axis2.ptr);\n        return ret === 0 ? undefined : RawJointParams.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawjointset_free(ptr);\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        var ret = wasm.rawjointset_jointBodyHandle1(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        var ret = wasm.rawjointset_jointBodyHandle2(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The type of this joint given as a string.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        var ret = wasm.rawjointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        var ret = wasm.rawjointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        var ret = wasm.rawjointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        var ret = wasm.rawjointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        var ret = wasm.rawjointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The first axis of this joint, if any.\n    *\n    * For joints where an application axis makes sense (e.g. the revolute and prismatic joins),\n    * this returns the application axis on the first rigid-body this joint is attached to, expressed\n    * in the local-space of this first rigid-body.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    jointAxis1(handle) {\n        var ret = wasm.rawjointset_jointAxis1(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The second axis of this joint, if any.\n    *\n    * For joints where an application axis makes sense (e.g. the revolute and prismatic joins),\n    * this returns the application axis on the second rigid-body this joint is attached to, expressed\n    * in the local-space of this second rigid-body.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    jointAxis2(handle) {\n        var ret = wasm.rawjointset_jointAxis2(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle) {\n        var ret = wasm.rawjointset_jointLimitsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * If this is a prismatic joint, returns its lower limit.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointLimitsMin(handle) {\n        var ret = wasm.rawjointset_jointLimitsMin(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointLimitsMax(handle) {\n        var ret = wasm.rawjointset_jointLimitsMax(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} model\n    */\n    jointConfigureMotorModel(handle, model) {\n        wasm.rawjointset_jointConfigureMotorModel(this.ptr, handle, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} vx\n    * @param {number} vy\n    * @param {number} vz\n    * @param {number} factor\n    */\n    jointConfigureBallMotorVelocity(handle, vx, vy, vz, factor) {\n        wasm.rawjointset_jointConfigureBallMotorVelocity(this.ptr, handle, vx, vy, vz, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} qw\n    * @param {number} qx\n    * @param {number} qy\n    * @param {number} qz\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureBallMotorPosition(handle, qw, qx, qy, qz, stiffness, damping) {\n        wasm.rawjointset_jointConfigureBallMotorPosition(this.ptr, handle, qw, qx, qy, qz, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} qw\n    * @param {number} qx\n    * @param {number} qy\n    * @param {number} qz\n    * @param {number} vx\n    * @param {number} vy\n    * @param {number} vz\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureBallMotor(handle, qw, qx, qy, qz, vx, vy, vz, stiffness, damping) {\n        wasm.rawjointset_jointConfigureBallMotor(this.ptr, handle, qw, qx, qy, qz, vx, vy, vz, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureUnitMotorVelocity(handle, targetVel, factor) {\n        wasm.rawjointset_jointConfigureUnitMotorVelocity(this.ptr, handle, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureUnitMotorPosition(handle, targetPos, stiffness, damping) {\n        wasm.rawjointset_jointConfigureUnitMotorPosition(this.ptr, handle, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureUnitMotor(handle, targetPos, targetVel, stiffness, damping) {\n        wasm.rawjointset_jointConfigureUnitMotor(this.ptr, handle, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawjointset_new();\n        return RawJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawJointParams} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @returns {number}\n    */\n    createJoint(bodies, params, parent1, parent2) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(params, RawJointParams);\n        var ret = wasm.rawjointset_createJoint(this.ptr, bodies.ptr, params.ptr, parent1, parent2);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawjointset_remove(this.ptr, handle, islands.ptr, bodies.ptr, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.rawjointset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        var ret = wasm.rawjointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawjointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawnarrowphase_new();\n        return RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contacts_with(handle1, f) {\n        wasm.rawnarrowphase_contacts_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        var ret = wasm.rawnarrowphase_contact_pair(this.ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersections_with(handle1, f) {\n        wasm.rawnarrowphase_intersections_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        var ret = wasm.rawnarrowphase_intersection_pair(this.ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPhysicsPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawphysicspipeline_new();\n        return RawPhysicsPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawJointSet} joints\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, ccd_solver.ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawJointSet} joints\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, ccd_solver.ptr, eventQueue.ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        var ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        var ret = wasm.rawpointcolliderprojection_point(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        var ret = wasm.rawpointcolliderprojection_isInside(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawQueryPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawquerypipeline_new();\n        return RawQueryPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(islands, bodies, colliders) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.ptr, islands.ptr, bodies.ptr, colliders.ptr);\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} groups\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(colliders, rayOrig, rayDir, maxToi, solid, groups) {\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        var ret = wasm.rawquerypipeline_castRay(this.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, groups);\n        return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} groups\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(colliders, rayOrig, rayDir, maxToi, solid, groups) {\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        var ret = wasm.rawquerypipeline_castRayAndGetNormal(this.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, groups);\n        return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} groups\n    * @param {Function} callback\n    */\n    intersectionsWithRay(colliders, rayOrig, rayDir, maxToi, solid, groups, callback) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, groups, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} groups\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(colliders, shapePos, shapeRot, shape, groups) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, groups);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} groups\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(colliders, point, solid, groups) {\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(point, RawVector);\n        var ret = wasm.rawquerypipeline_projectPoint(this.ptr, colliders.ptr, point.ptr, solid, groups);\n        return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} groups\n    * @param {Function} callback\n    */\n    intersectionsWithPoint(colliders, point, groups, callback) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.ptr, colliders.ptr, point.ptr, groups, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {number} groups\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(colliders, shapePos, shapeRot, shapeVel, shape, maxToi, groups) {\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(shapeVel, RawVector);\n        _assertClass(shape, RawShape);\n        var ret = wasm.rawquerypipeline_castShape(this.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shapeVel.ptr, shape.ptr, maxToi, groups);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} groups\n    * @param {Function} callback\n    */\n    intersectionsWithShape(colliders, shapePos, shapeRot, shape, groups, callback) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, groups, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            var ptr0 = aabbCenter.ptr;\n            aabbCenter.ptr = 0;\n            _assertClass(aabbHalfExtents, RawVector);\n            var ptr1 = aabbHalfExtents.ptr;\n            aabbHalfExtents.ptr = 0;\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, ptr0, ptr1, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        var ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        var ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        var ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        var ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        var ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        var ret = wasm.rawrigidbodyset_rbTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        var ret = wasm.rawrigidbodyset_rbRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        var ret = wasm.rawrigidbodyset_rbIsSleeping(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        var ret = wasm.rawrigidbodyset_rbIsMoving(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        var ret = wasm.rawrigidbodyset_rbNextTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        var ret = wasm.rawrigidbodyset_rbNextRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.ptr, handle, linvel.ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.ptr, handle, angvel.ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        var ret = wasm.rawrigidbodyset_rbLinvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        var ret = wasm.rawrigidbodyset_rbAngvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbRestrictRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbRestrictRotations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        var ret = wasm.rawrigidbodyset_rbDominanceGroup(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        var ret = wasm.rawrigidbodyset_rbMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        var ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        var ret = wasm.rawrigidbodyset_rbNumColliders(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        var ret = wasm.rawrigidbodyset_rbCollider(this.ptr, handle, at);\n        return ret >>> 0;\n    }\n    /**\n    * The status of this rigid-body: static, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbBodyType(handle) {\n        var ret = wasm.rawrigidbodyset_rbBodyType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Is this rigid-body static?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsStatic(handle) {\n        var ret = wasm.rawrigidbodyset_rbIsStatic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        var ret = wasm.rawrigidbodyset_rbIsKinematic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        var ret = wasm.rawrigidbodyset_rbIsDynamic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        var ret = wasm.rawrigidbodyset_rbLinearDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        var ret = wasm.rawrigidbodyset_rbAngularDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        var ret = wasm.rawrigidbodyset_rbGravityScale(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Applies a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbApplyForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbApplyForce(this.ptr, handle, force.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.ptr, handle, impulse.ptr, wakeUp);\n    }\n    /**\n    * Applies a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorque(this.ptr, handle, torque.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, handle, torque_impulse.ptr, wakeUp);\n    }\n    /**\n    * Applies a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyForceAtPoint(this.ptr, handle, force.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, handle, impulse.ptr, point.ptr, wakeUp);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawrigidbodyset_new();\n        return RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} translationsEnabled\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {number} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @returns {number}\n    */\n    createRigidBody(translation, rotation, gravityScale, mass, translationsEnabled, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, ccdEnabled, dominanceGroup) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        var ret = wasm.rawrigidbodyset_createRigidBody(this.ptr, translation.ptr, rotation.ptr, gravityScale, mass, translationsEnabled, centerOfMass.ptr, linvel.ptr, angvel.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, ccdEnabled, dominanceGroup);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawJointSet} joints\n    */\n    remove(handle, islands, colliders, joints) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawJointSet);\n        wasm.rawrigidbodyset_remove(this.ptr, handle, islands.ptr, colliders.ptr, joints.ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.rawrigidbodyset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        var ret = wasm.rawrigidbodyset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRotation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        var ret = wasm.rawrotation_new(x, y, z, w);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        var ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        var ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        var ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        var ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        var ret = wasm.rawintegrationparameters_jointErp(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawSerializationPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.rawserializationpipeline_new();\n        return RawSerializationPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawJointSet} joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawJointSet);\n        var ret = wasm.rawserializationpipeline_serializeAll(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        var ret = wasm.rawserializationpipeline_deserializeAll(this.ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShape.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        var ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        var ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        var ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        var ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        var ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        var ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        var ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        var ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale) {\n        var ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        var ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        var ret = wasm.rawshape_segment(p1.ptr, p2.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        var ret = wasm.rawshape_triangle(p1.ptr, p2.ptr, p3.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        var ret = wasm.rawshape_roundTriangle(p1.ptr, p2.ptr, p3.ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        var ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        var ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        var ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        var ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        var ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        var ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        var ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        var ret = wasm.rawshapecollidertoi_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        var ret = wasm.rawshapecollidertoi_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawVector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        var ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        var ret = wasm.rawvector_new(x, y, z);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        var ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        var ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawvector_set_y(this.ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        var ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        var ret = wasm.rawvector_xyz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        var ret = wasm.rawvector_yxz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        var ret = wasm.rawvector_zxy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        var ret = wasm.rawvector_xzy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        var ret = wasm.rawvector_yzx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        var ret = wasm.rawvector_zyx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('rapier_wasm3d_bg.wasm', \"<deleted>\");\n    }\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        var ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_rawraycolliderintersection_new = function(arg0) {\n        var ret = RawRayColliderIntersection.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        var ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_now_885ca88fafee0fd1 = function(arg0) {\n        var ret = getObject(arg0).now();\n        return ret;\n    };\n    imports.wbg.__wbg_newnoargs_1a11e7e8c906996c = function(arg0, arg1) {\n        var ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_6d26c712aa73c8b2 = function() { return handleError(function (arg0, arg1) {\n        var ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e91f71ddf1f45cff = function() { return handleError(function (arg0, arg1) {\n        var ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        var ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_e3c72355d091d5d4 = function() { return handleError(function (arg0, arg1, arg2) {\n        var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_c143b19d87139944 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        var ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_72facd37dbc97ddb = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        var ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_bind_07839579f523aa89 = function(arg0, arg1, arg2, arg3) {\n        var ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_79a3294266d4e783 = function(arg0) {\n        var ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_b4546ea7b590539e = function() { return handleError(function () {\n        var ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_c279fea81f426a68 = function() { return handleError(function () {\n        var ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_038a6ea0ff17789f = function() { return handleError(function () {\n        var ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_4f93ce884bcee597 = function() { return handleError(function () {\n        var ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        var ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_22a36e6023ad3cd0 = function(arg0, arg1, arg2) {\n        var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_945397fb09fec0b8 = function(arg0) {\n        var ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_223873223acf6d07 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_68e13e7bbd918464 = function(arg0) {\n        var ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        var ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        var ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        var ret = debugString(getObject(arg1));\n        var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        var ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n\n\n    const { instance, module } = await load(await input, imports);\n\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n\n    return wasm;\n}\n\nexport default init;\n\n","import {RawRigidBodySet} from \"../raw\"\nimport {Rotation, RotationOps, Vector, VectorOps} from '../math';\nimport {ColliderHandle} from \"../geometry\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type RigidBodyHandle = number;\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport enum RigidBodyType {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    Dynamic = 0,\n    /**\n     * A `RigidBodyType::Static` body cannot be affected by external forces.\n     */\n    Static,\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicPositionBased,\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicVelocityBased,\n}\n\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    private rawSet: RawRigidBodySet; // The RigidBody won't need to free this.\n    readonly handle: RigidBodyHandle;\n\n    constructor(rawSet: RawRigidBodySet, handle: RigidBodyHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockTranslations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockRotations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public restrictRotations(enableX: boolean, enableY: boolean, enableZ: boolean, wakeUp: boolean) {\n        return this.rawSet.rbRestrictRotations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    public dominanceGroup(): number {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    public setDominanceGroup(group: number) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    public enableCcd(enabled: boolean) {\n        this.rawSet.rbEnableCcd(this.handle, enabled)\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextTranslation(): Vector {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextRotation(): Rotation {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    public setTranslation(tra: Vector, wakeUp: boolean,) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n\n    /**\n     * Sets the linear velocity fo this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setLinvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    public gravityScale(): number {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setGravityScale(factor: number, wakeUp: boolean) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    public setRotation(rot: Rotation, wakeUp: boolean) {\n        this.rawSet.rbSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w, wakeUp);\n    }\n\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setAngvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    // #endif\n\n\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    public setNextKinematicTranslation(t: Vector) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    public setNextKinematicRotation(rot: Rotation) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n\n    // #endif\n\n\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    public linvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    public angvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n\n    // #endif\n\n\n    /**\n     * The mass of this rigid-body.\n     */\n    public mass(): number {\n        return this.rawSet.rbMass(this.handle);\n    }\n\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    public sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    public wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    public isCcdEnabled() {\n        this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    public numColliders(): number {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n\n    /**\n     * Retrieves the handle of the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    public collider(i: number): ColliderHandle {\n        return this.rawSet.rbCollider(this.handle, i);\n    }\n\n\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    public bodyType(): RigidBodyType {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n\n    /**\n     * Is this rigid-body sleeping?\n     */\n    public isSleeping(): boolean {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    public isMoving(): boolean {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n\n    /**\n     * Is this rigid-body static?\n     */\n    public isStatic(): boolean {\n        return this.rawSet.rbIsStatic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body kinematic?\n     */\n    public isKinematic(): boolean {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body dynamic?\n     */\n    public isDynamic(): boolean {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    public linearDamping(): number {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    public angularDamping(): number {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setLinearDamping(factor: number) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setAngularDamping(factor: number) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n\n    /**\n     * Applies a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyForce(force: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbApplyForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulse(\n        impulse: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n\n\n    // #if DIM3\n    /**\n     * Applies a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorque(torque: Vector, wakeUp: boolean) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbApplyTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorqueImpulse(torqueImpulse: Vector, wakeUp: boolean) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n\n    // #endif\n\n    /**\n     * Applies a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyForceAtPoint(\n        force: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulseAtPoint(\n        impulse: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\n\nexport class RigidBodyDesc {\n    translation: Vector;\n    rotation: Rotation;\n    gravityScale: number;\n    mass: number;\n    translationsEnabled: boolean;\n    centerOfMass: Vector;\n    linvel: Vector;\n    // #if DIM3\n    angvel: Vector;\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    rotationsEnabledX: boolean;\n    rotationsEnabledY: boolean;\n    rotationsEnabledZ: boolean;\n    // #endif\n    linearDamping: number\n    angularDamping: number\n    status: RigidBodyType;\n    canSleep: boolean;\n    ccdEnabled: boolean;\n    dominanceGroup: number;\n\n    constructor(status: RigidBodyType) {\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.translationsEnabled = true;\n        this.centerOfMass = VectorOps.zeros();\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    public static newDynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic)\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    public static newKinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased)\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    public static newKinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased)\n    }\n\n    /**\n     * A rigid-body descriptor used to build a static rigid-body.\n     */\n    public static newStatic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Static)\n    }\n\n    public setDominanceGroup(group: number): RigidBodyDesc {\n        this.dominanceGroup = group;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    public setTranslation(x: number, y: number, z: number): RigidBodyDesc {\n        if (typeof x != \"number\" || typeof y != \"number\" || typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    public setRotation(rot: Rotation): RigidBodyDesc {\n        this.rotation = rot;\n        return this;\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    public setGravityScale(scale: number): RigidBodyDesc {\n        this.gravityScale = scale;\n        return this;\n    }\n\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    public setAdditionalMass(mass: number): RigidBodyDesc {\n        this.mass = mass;\n        return this;\n    }\n\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockTranslations(): RigidBodyDesc {\n        this.translationsEnabled = false;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    public setLinvel(x: number, y: number, z: number): RigidBodyDesc {\n        if (typeof x != \"number\" || typeof y != \"number\" || typeof z != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n\n        this.linvel = {x: x, y: y, z: z};\n        return this;\n    }\n\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    public setAngvel(vel: Vector): RigidBodyDesc {\n        this.angvel = vel;\n        return this;\n    }\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setAdditionalMassProperties(mass: number, centerOfMass: Vector, principalAngularInertia: Vector, angularInertiaLocalFrame: Rotation): RigidBodyDesc {\n        this.mass = mass;\n        this.centerOfMass = centerOfMass;\n        this.principalAngularInertia = principalAngularInertia;\n        this.angularInertiaLocalFrame = angularInertiaLocalFrame;\n        return this;\n    }\n\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     */\n    public setAdditionalPrincipalAngularInertia(principalAngularInertia: Vector): RigidBodyDesc {\n        this.principalAngularInertia = principalAngularInertia;\n        return this;\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    public restrictRotations(rotationsEnabledX: boolean, rotationsEnabledY: boolean, rotationsEnabledZ: boolean): RigidBodyDesc {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockRotations(): RigidBodyDesc {\n        return this.restrictRotations(false, false, false);\n    }\n\n    // #endif\n\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    public setLinearDamping(damping: number): RigidBodyDesc {\n        this.linearDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    public setAngularDamping(damping: number): RigidBodyDesc {\n        this.angularDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    public setCanSleep(can: boolean): RigidBodyDesc {\n        this.canSleep = can;\n        return this;\n    }\n\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    public setCcdEnabled(enabled: boolean): RigidBodyDesc {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n}","import {RawVector, RawRotation} from \"./raw\";\n\n\n\n// #if DIM3\nexport interface Vector {\n    x: number;\n    y: number;\n    z: number;\n}\n\n/**\n * A 3D vector.\n */\nexport class Vector3 implements Vector {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\nexport class VectorOps {\n    public static new(x: number, y: number, z: number): Vector {\n        return new Vector3(x, y, z);\n    }\n\n    public static intoRaw(v: Vector): RawVector {\n        return new RawVector(v.x, v.y, v.z);\n    }\n\n    public static zeros(): Vector {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n\n    // FIXME: type ram: RawVector?\n    public static fromRaw(raw: RawVector): Vector {\n        if (!raw)\n            return null;\n\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n}\n\nexport interface Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\n/**\n * A quaternion.\n */\nexport class Quaternion implements Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n\n    constructor(x: number, y: number, z: number, w: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\n\nexport class RotationOps {\n    public static identity(): Rotation {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n\n    public static fromRaw(raw: RawRotation): Rotation {\n        if (!raw)\n            return null;\n\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(rot: Rotation): RawRotation {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n}\n\n// #endif","import {Rotation, Vector, VectorOps, RotationOps} from \"../math\";\nimport {RawJointParams, RawJointSet, RawRigidBodySet} from \"../raw\";\nimport {RigidBodyHandle} from \"./rigid_body\"\n// #if DIM3\nimport {Quaternion} from \"../math\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type JointHandle = number;\n\n/**\n * An enum grouping all possible types of joints:\n * - `Ball`: A Ball joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Revolute`: (3D only) A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n */\nexport enum JointType {\n    Ball,\n    Fixed,\n    Prismatic,\n    // #if DIM3\n    Revolute,\n    // #endif\n}\n\nexport enum SpringModel {\n    Disabled,\n    VelocityBased,\n    AccelerationBased,\n    ForceBased,\n}\n\nexport class Joint {\n    protected rawSet: RawJointSet; // The Joint won't need to free this.\n    handle: JointHandle;\n\n    constructor(rawSet: RawJointSet, handle: JointHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The unique integer identifier of the first rigid-body this joint it attached to.\n     */\n    public bodyHandle1(): RigidBodyHandle {\n        return this.rawSet.jointBodyHandle1(this.handle);\n    }\n\n    /**\n     * The unique integer identifier of the second rigid-body this joint is attached to.\n     */\n    public bodyHandle2(): RigidBodyHandle {\n        return this.rawSet.jointBodyHandle2(this.handle);\n    }\n\n    /**\n     * The type of this joint given as a string.\n     */\n    public type(): JointType {\n        return this.rawSet.jointType(this.handle);\n    }\n\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    public frameX1(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n\n    // #endif\n\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    public frameX2(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n\n    // #endif\n\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public anchor1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public anchor2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n\n    /**\n     * The first axis of this joint, if any.\n     *\n     * For joints where an application axis makes sense (e.g. the revolute and prismatic joins),\n     * this returns the application axis on the first rigid-body this joint is attached to, expressed\n     * in the local-space of this first rigid-body.\n     */\n    public axis1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAxis1(this.handle));\n    }\n\n    /**\n     * The second axis of this joint, if any.\n     *\n     * For joints where an application axis makes sense (e.g. the revolute and prismatic joins),\n     * this returns the application axis on the second rigid-body this joint is attached to, expressed\n     * in the local-space of this second rigid-body.\n     */\n    public axis2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAxis2(this.handle))\n    }\n}\n\nexport class UnitJoint extends Joint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    public limitsEnabled(): boolean {\n        return this.rawSet.jointLimitsEnabled(this.handle);\n    }\n\n    /**\n     * The min limit of this joint.\n     */\n    public limitsMin(): number {\n        return this.rawSet.jointLimitsMin(this.handle);\n    }\n\n    /**\n     * The max limit of this joint.\n     */\n    public limitsMax(): number {\n        return this.rawSet.jointLimitsMax(this.handle);\n    }\n\n    public configureMotorModel(model: SpringModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: number, factor: number) {\n        this.rawSet.jointConfigureUnitMotorVelocity(this.handle, targetVel, factor);\n    }\n\n    public configureMotorPosition(targetPos: number, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureUnitMotorPosition(this.handle, targetPos, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: number, targetVel: number, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureUnitMotor(this.handle, targetPos, targetVel, stiffness, damping);\n    }\n}\n\nexport class FixedJoint extends Joint {}\nexport class PrismaticJoint extends UnitJoint {}\n\n\n// #if DIM3\nexport class BallJoint extends Joint {\n    public configureMotorModel(model: SpringModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n}\n\nexport class RevoluteJoint extends UnitJoint {}\n// #endif\n\n\n\nexport class JointParams {\n    anchor1: Vector\n    anchor2: Vector\n    axis1: Vector\n    axis2: Vector\n    tangent1: Vector\n    tangent2: Vector\n    frame1: Rotation\n    frame2: Rotation\n    jointType: JointType\n    limitsEnabled: boolean\n    limits: Array<number>\n\n    private constructor() {\n    }\n\n    /**\n     * Create a new joint descriptor that builds Ball joints.\n     *\n     * A ball joints allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    public static ball(anchor1: Vector, anchor2: Vector): JointParams {\n        let res = new JointParams();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Ball;\n        return res;\n    }\n\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    public static fixed(anchor1: Vector, frame1: Rotation, anchor2: Vector, frame2: Rotation): JointParams {\n        let res = new JointParams();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n\n\n    // #if DIM3\n\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis1 - Axis of the joint, expressed in the local-space of the first rigid-body it is attached to.\n     * @param tangent1 - A vector orthogonal to `axis1`. It is used to compute a basis orthonormal\n     *                   to the joint's axis. If this tangent is set to the zero vector, the orthonormal\n     *                   basis will be automatically computed arbitrarily.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis2 - Axis of the joint, expressed in the local-space of the second rigid-body it is attached to.\n     * @param tangent2 - A vector orthogonal to `axis2`. It is used to compute a basis orthonormal\n     *                   to the joint's axis. If this tangent is set to the zero vector, the orthonormal\n     *                   basis will be automatically computed arbitrarily.\n     */\n    public static prismatic(\n        anchor1: Vector,\n        axis1: Vector,\n        tangent1: Vector,\n        anchor2: Vector,\n        axis2: Vector,\n        tangent2: Vector,\n    ): JointParams {\n        let res = new JointParams();\n        res.anchor1 = anchor1;\n        res.axis1 = axis1;\n        res.tangent1 = tangent1;\n        res.anchor2 = anchor2;\n        res.axis2 = axis2;\n        res.tangent2 = tangent2;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis1 - Axis of the joint, expressed in the local-space of the first rigid-body it is attached to.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis2 - Axis of the joint, expressed in the local-space of the second rigid-body it is attached to.\n     */\n    public static revolute(\n        anchor1: Vector,\n        axis1: Vector,\n        anchor2: Vector,\n        axis2: Vector,\n    ): JointParams {\n        let res = new JointParams();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis1 = axis1;\n        res.axis2 = axis2;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n\n    // #endif\n\n    public intoRaw(): RawJointParams {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx1;\n        let rawAx2;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n\n        switch (this.jointType) {\n            case JointType.Ball:\n                result = RawJointParams.ball(rawA1, rawA2);\n                break;\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawJointParams.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Prismatic:\n                rawAx1 = VectorOps.intoRaw(this.axis1);\n                rawAx2 = VectorOps.intoRaw(this.axis2);\n\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n\n\n                // #if DIM3\n                let rawTa1 = VectorOps.intoRaw(this.tangent1);\n                let rawTa2 = VectorOps.intoRaw(this.tangent2);\n                result = RawJointParams.prismatic(\n                    rawA1,\n                    rawAx1,\n                    rawTa1,\n                    rawA2,\n                    rawAx2,\n                    rawTa2,\n                    limitsEnabled,\n                    limitsMin,\n                    limitsMax,\n                );\n                rawTa1.free();\n                rawTa2.free();\n                // #endif\n\n                rawAx1.free();\n                rawAx2.free();\n                break;\n            // #if DIM3\n            case JointType.Revolute:\n                rawAx1 = VectorOps.intoRaw(this.axis1);\n                rawAx2 = VectorOps.intoRaw(this.axis2);\n                result = RawJointParams.revolute(rawA1, rawAx1, rawA2, rawAx2);\n                rawAx1.free();\n                rawAx2.free();\n                break;\n            // #endif\n        }\n\n        rawA1.free();\n        rawA2.free();\n\n        return result;\n    }\n}","import {RawRigidBodySet} from \"../raw\"\nimport {VectorOps, RotationOps} from '../math';\nimport {RigidBody, RigidBodyDesc, RigidBodyHandle} from './rigid_body'\nimport {ColliderSet} from \"../geometry\";\nimport {JointSet} from \"./joint_set\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    raw: RawRigidBodySet;\n\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawRigidBodySet) {\n        this.raw = raw || new RawRigidBodySet();\n    }\n\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    public createRigidBody(desc: RigidBodyDesc): RigidBodyHandle {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n\n        let handle = this.raw.createRigidBody(\n            rawTra,\n            rawRot,\n            desc.gravityScale,\n            desc.mass,\n            desc.translationsEnabled,\n            rawCom,\n            rawLv,\n            // #if DIM3\n            rawAv,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            desc.rotationsEnabledX,\n            desc.rotationsEnabledY,\n            desc.rotationsEnabledZ,\n            // #endif\n            desc.linearDamping,\n            desc.angularDamping,\n            desc.status,\n            desc.canSleep,\n            desc.ccdEnabled,\n            desc.dominanceGroup,\n        );\n\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        return handle;\n    }\n\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param joints - The set of joints that may contain joints attached to the removed rigid-body.\n     */\n    public remove(handle: RigidBodyHandle, islands: IslandManager, colliders: ColliderSet, joints: JointSet) {\n        this.raw.remove(handle, islands.raw, colliders.raw, joints.raw)\n    }\n\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    public len(): number {\n        return this.raw.len();\n    }\n\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    public contains(handle: RigidBodyHandle): boolean {\n        return this.raw.contains(handle);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: RigidBodyHandle): RigidBody {\n        if (this.raw.contains(handle)) {\n            return new RigidBody(this.raw, handle);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.forEachRigidBodyHandle((handle) => {\n            f(new RigidBody(this.raw, handle))\n        })\n    }\n\n    /**\n     * Applies the given closure to the handle of each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachRigidBodyHandle(f)\n    }\n\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBody(islands: IslandManager, f: (body: RigidBody) => void) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(new RigidBody(this.raw, handle))\n        })\n    }\n}\n","import {RawIntegrationParameters} from \"../raw\";\n\nexport class IntegrationParameters {\n    raw: RawIntegrationParameters\n\n    constructor(raw?: RawIntegrationParameters) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt(): number {\n        return this.raw.dt;\n    }\n\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp(): number {\n        return this.raw.erp;\n    }\n\n    /**\n     * The Error Reduction Parameter for joints in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get jointErp(): number {\n        return this.raw.jointErp;\n    }\n\n    /**\n     * Each cached impulse are multiplied by this coefficient in `[0, 1]`\n     * when they are re-used to initialize the solver (default `1.0`).\n     */\n    get warmstartCoeff(): number {\n        return this.raw.warmstartCoeff;\n    }\n\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError(): number {\n        return this.raw.allowedLinearError;\n    }\n\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance(): number {\n        return this.raw.predictionDistance;\n    }\n\n    /**\n     * Amount of angular drift of joint limits the engine wont\n     * attempt to correct (default: `0.001rad`).\n     */\n    get allowedAngularError(): number {\n        return this.raw.allowedAngularError;\n    }\n\n    /**\n     * Maximum linear correction during one step of the non-linear position solver (default: `0.2`).\n     */\n    get maxLinearCorrection(): number {\n        return this.raw.maxLinearCorrection;\n    }\n\n    /**\n     * Maximum angular correction during one step of the non-linear position solver (default: `0.2`).\n     */\n    get maxAngularCorrection(): number {\n        return this.raw.maxAngularCorrection;\n    }\n\n    /**\n     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).\n     */\n    get maxVelocityIterations(): number {\n        return this.raw.maxVelocityIterations;\n    }\n\n    /**\n     * Maximum number of iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxPositionIterations(): number {\n        return this.raw.maxPositionIterations;\n    }\n\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize(): number {\n        return this.raw.minIslandSize;\n    }\n\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.raw.maxCcdSubsteps;\n    }\n\n\n    set dt(value: number) {\n        this.raw.dt = value;\n    }\n\n    set erp(value: number) {\n        this.raw.erp = value;\n    }\n\n    set jointErp(value: number) {\n        this.raw.jointErp = value;\n    }\n\n    set warmstartCoeff(value: number) {\n        this.raw.warmstartCoeff = value;\n    }\n\n    set allowedLinearError(value: number) {\n        this.raw.allowedLinearError = value;\n    }\n\n    set predictionDistance(value: number) {\n        this.raw.predictionDistance = value;\n    }\n\n    set allowedAngularError(value: number) {\n        this.raw.allowedAngularError = value;\n    }\n\n    set maxLinearCorrection(value: number) {\n        this.raw.maxLinearCorrection = value;\n    }\n\n    set maxAngularCorrection(value: number) {\n        this.raw.maxAngularCorrection = value;\n    }\n\n    set maxVelocityIterations(value: number) {\n        this.raw.maxVelocityIterations = value;\n    }\n\n    set maxPositionIterations(value: number) {\n        this.raw.maxPositionIterations = value;\n    }\n\n    set minIslandSize(value: number) {\n        this.raw.minIslandSize = value;\n    }\n\n    set maxCcdSubsteps(value: number) {\n        this.raw.maxCcdSubsteps = value;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport enum CoefficientCombineRule {\n    Average = 0,\n    Min = 1,\n    Multiply = 2,\n    Max = 3,\n}","import {RawJointSet} from \"../raw\"\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    BallJoint,\n    FixedJoint,\n    Joint,\n    JointHandle,\n    JointParams,\n    JointType,\n    PrismaticJoint,\n    // #if DIM3\n    RevoluteJoint\n    // #endif\n} from \"./joint\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class JointSet {\n    raw: RawJointSet;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawJointSet) {\n        this.raw = raw || new RawJointSet();\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     */\n    public createJoint(\n        bodies: RigidBodySet,\n        desc: JointParams,\n        parent1: number,\n        parent2: number\n    ): number {\n        const rawParams = desc.intoRaw();\n        const result = this.raw.createJoint(bodies.raw, rawParams, parent1, parent2);\n        rawParams.free();\n        return result;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param bodies - The set of rigid-bodies containing the rigid-bodies attached by the removed joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: JointHandle, islands: IslandManager, bodies: RigidBodySet, wake_up: boolean) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wake_up);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.raw.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: JointHandle): boolean {\n        return this.raw.contains(handle);\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     * Note that two distinct calls with the same `handle` will return two\n     * different JavaScript objects that both represent the same joint.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: JointHandle): Joint {\n        if (this.raw.contains(handle)) {\n            switch (this.raw.jointType(handle)) {\n                case JointType.Ball:\n                    return new BallJoint(this.raw, handle);\n                case JointType.Prismatic:\n                    return new PrismaticJoint(this.raw, handle);\n                case JointType.Fixed:\n                    return new FixedJoint(this.raw, handle);\n                // #if DIM3\n                case JointType.Revolute:\n                    return new RevoluteJoint(this.raw, handle);\n                // #endif\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Applies the given closure to each joints contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachJoint(f: (handle: Joint) => void) {\n        this.raw.forEachJointHandle((handle: number) => {\n            f(new Joint(this.raw, handle))\n        });\n    }\n\n    /**\n     * Applies the given closure to the handle of each joints contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachJointHandle(f: (handle: JointHandle) => void) {\n        this.raw.forEachJointHandle(f);\n    }\n}\n","import {Vector, VectorOps} from \"../math\"\nimport {RawShape} from \"../raw\";\n\n\n// #if DIM3\n/**\n * The type of a shape supported by Rapier.\n */\nexport type Shape = Ball | Cuboid | Capsule | Segment | Triangle\n    | TriMesh | Heightfield | ConvexPolyhedron | Cylinder\n    | Cone | RoundCuboid | RoundCylinder | RoundCone | RoundConvexPolyhedron\n\n/**\n * An enumeration representing the type of a shape.\n */\nexport enum ShapeType {\n    Ball = 0,\n    Cuboid = 1,\n    Capsule = 2,\n    Segment = 3,\n    Polyline = 4,\n    Triangle = 5,\n    TriMesh = 6,\n    HeightField = 7,\n    // Compound = 8,\n    ConvexPolyhedron = 9,\n    Cylinder = 10,\n    Cone = 11,\n    RoundCuboid = 12,\n    RoundTriangle = 13,\n    RoundCylinder = 14,\n    RoundCone = 15,\n    RoundConvexPolyhedron = 16,\n}\n\n// #endif\n\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball {\n    /**\n     * The balls radius.\n     */\n    readonly radius: number;\n\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.ball(this.radius);\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid {\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx: number, hy: number, hz: number) {\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);\n        // #endif\n    }\n}\n\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid {\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    /**\n     * The radius of the cuboid's round border.\n     */\n    borderRadius: number;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx: number, hy: number, hz: number, borderRadius: number) {\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);\n        // #endif\n    }\n}\n\n/**\n * A shape that is a capsule.\n */\nexport class Capsule {\n    /**\n     * The radius of the capsule's basis.\n     */\n    readonly radius: number;\n\n    /**\n     * The capsule's half height, along the `y` axis.\n     */\n    readonly halfHeight: number;\n\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Segment {\n    /**\n     * The first point of the segment.\n     */\n    readonly a: Vector;\n\n    /**\n     * The second point of the segment.\n     */\n    readonly b: Vector;\n\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a: Vector, b: Vector) {\n        this.a = a;\n        this.b = b;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Triangle {\n    /**\n     * The first point of the triangle.\n     */\n    readonly a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    readonly b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    readonly c: Vector;\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle {\n    /**\n     * The first point of the triangle.\n     */\n    readonly a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    readonly b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    readonly c: Vector;\n\n    /**\n     * The radius of the triangles's rounded edges and vertices.\n     * In 3D, this is also equal to half the thickness of the round triangle.\n     */\n    readonly borderRadius: number;\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector, borderRadius: number) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline {\n    /**\n     * The vertices of the polyline.\n     */\n    readonly vertices: Float32Array;\n\n    /**\n     * The indices of the segments.\n     */\n    readonly indices: Uint32Array;\n\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices: Float32Array, indices: Uint32Array) {\n        this.vertices = vertices;\n        this.indices = !!indices ? indices : new Uint32Array(0);\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh {\n    /**\n     * The vertices of the triangle mesh.\n     */\n    readonly vertices: Float32Array;\n\n    /**\n     * The indices of the triangles.\n     */\n    readonly indices: Uint32Array;\n\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices: Float32Array, indices: Uint32Array) {\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n\n\n\n\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron {\n    /**\n     * The vertices of the convex polygon.\n     */\n    readonly vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    readonly indices: Uint32Array | null;\n\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices: Float32Array, indices: Uint32Array | null) {\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        } else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n\n\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron {\n    /**\n     * The vertices of the convex polygon.\n     */\n    readonly vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    readonly indices: Uint32Array | null;\n\n    /**\n     * The radius of the convex polyhedron's rounded edges and vertices.\n     */\n    readonly borderRadius: number;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(vertices: Float32Array, indices: Uint32Array | null, borderRadius: number) {\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(this.vertices, this.indices, this.borderRadius);\n        } else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield {\n    /**\n     * The number of rows in the heights matrix.\n     */\n    readonly nrows: number;\n\n    /**\n     * The number of columns in the heights matrix.\n     */\n    readonly ncols: number;\n\n    /**\n     * The heights of the heightfield along its local `y` axis,\n     * provided as a matrix stored in column-major order.\n     */\n    readonly heights: Float32Array;\n\n    /**\n     * The dimensions of the heightfield's local `x,z` plane.\n     */\n    readonly scale: Vector;\n\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(nrows: number, ncols: number, heights: Float32Array, scale: Vector) {\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n    }\n\n    public intoRaw(): RawShape {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.nrows, this.ncols, this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder {\n    /**\n     * The radius of the cylinder's basis.\n     */\n    readonly radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    readonly halfHeight: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n\n\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder {\n    /**\n     * The radius of the cylinder's basis.\n     */\n    readonly radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    readonly halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    readonly borderRadius: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCylinder(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone {\n    /**\n     * The radius of the cone's basis.\n     */\n    readonly radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    readonly halfHeight: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone {\n    /**\n     * The radius of the cone's basis.\n     */\n    readonly radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    readonly halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    readonly borderRadius: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCone(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n\n// #endif","import {RawCCDSolver} from \"../raw\"\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    raw: RawCCDSolver;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawCCDSolver) {\n        this.raw = raw || new RawCCDSolver();\n    }\n}","import {RawIslandManager} from \"../raw\"\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    raw: RawIslandManager;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawIslandManager) {\n        this.raw = raw || new RawIslandManager();\n    }\n\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachActiveRigidBodyHandle(f)\n    }\n}","import {RawBroadPhase} from \"../raw\"\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    raw: RawBroadPhase;\n\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawBroadPhase) {\n        this.raw = raw || new RawBroadPhase();\n    }\n}","import {RawNarrowPhase, RawContactManifold} from \"../raw\"\nimport {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    raw: RawNarrowPhase;\n    tempManifold: TempContactManifold;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawNarrowPhase) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(collider1: ColliderHandle, f: (collider2: ColliderHandle) => void) {\n        this.raw.contacts_with(collider1, f)\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(collider1: ColliderHandle, f: (collider2: ColliderHandle) => void) {\n        this.raw.intersections_with(collider1, f)\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(collider1: ColliderHandle, collider2: ColliderHandle, f: (manifold: TempContactManifold, flipped: boolean) => void) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: ColliderHandle, collider2: ColliderHandle): boolean {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\n\nexport class TempContactManifold {\n    raw: RawContactManifold;\n\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw: RawContactManifold) {\n        this.raw = raw;\n    }\n\n    public normal(): Vector {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n\n    public localNormal1(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n\n    public localNormal2(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n\n    public subshape1(): number {\n        return this.raw.subshape1();\n    }\n\n    public subshape2(): number {\n        return this.raw.subshape2();\n    }\n\n    public numContacts(): number {\n        return this.raw.num_contacts();\n    }\n\n    public localContactPoint1(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n\n    public localContactPoint2(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n\n    public contactDist(i: number): number {\n        return this.raw.contact_dist(i);\n    }\n\n    public contactFid1(i: number): number {\n        return this.raw.contact_fid1(i);\n    }\n\n    public contactFid2(i: number): number {\n        return this.raw.contact_fid2(i);\n    }\n\n    public contactImpulse(i: number): number {\n        return this.raw.contact_impulse(i);\n    }\n\n\n    // #if DIM3\n    public contactTangentImpulseX(i: number): number {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n\n    public contactTangentImpulseY(i: number): number {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n\n    public numSolverContacts(): number {\n        return this.raw.num_solver_contacts();\n    }\n\n    public solverContactPoint(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n\n    public solverContactDist(i: number): number {\n        return this.raw.solver_contact_dist(i);\n    }\n\n    public solverContactFriction(i: number): number {\n        return this.raw.solver_contact_friction(i);\n    }\n\n    public solverContactRestitution(i: number): number {\n        return this.raw.solver_contact_restitution(i);\n    }\n\n    public solverContactTangentVelocity(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}","import {RawColliderSet} from \"../raw\"\nimport {Rotation, RotationOps, Vector, VectorOps} from '../math';\nimport {CoefficientCombineRule, RigidBodyHandle} from '../dynamics';\nimport {ActiveHooks, ActiveEvents} from \"../pipeline\";\nimport {InteractionGroups} from './interaction_groups';\nimport {\n    Shape,\n    Cuboid, Ball, ShapeType, Capsule, TriMesh, Polyline, Heightfield,\n    Segment, Triangle, RoundTriangle, RoundCuboid,\n    // #if DIM3\n    Cylinder, RoundCylinder, Cone, RoundCone,\n    ConvexPolyhedron, RoundConvexPolyhedron,\n    // #endif\n} from './shape';\n\n/// Flags affecting whether or not collision-detection happens between two colliders\n/// depending on the type of rigid-bodies they are attached to.\nexport enum ActiveCollisionTypes {\n    /// Enable collision-detection between a collider attached to a dynamic body\n    /// and another collider attached to a dynamic body.\n    DYNAMIC_DYNAMIC = 0b0000_0000_0000_0001,\n    /// Enable collision-detection between a collider attached to a dynamic body\n    /// and another collider attached to a kinematic body.\n    DYNAMIC_KINEMATIC = 0b0000_0000_0000_1100,\n    /// Enable collision-detection between a collider attached to a dynamic body\n    /// and another collider attached to a static body (or not attached to any body).\n    DYNAMIC_STATIC  = 0b0000_0000_0000_0010,\n    /// Enable collision-detection between a collider attached to a kinematic body\n    /// and another collider attached to a kinematic body.\n    KINEMATIC_KINEMATIC = 0b1100_1100_0000_0000,\n\n    /// Enable collision-detection between a collider attached to a kinematic body\n    /// and another collider attached to a static body (or not attached to any body).\n    KINEMATIC_STATIC = 0b0010_0010_0000_0000,\n\n    /// Enable collision-detection between a collider attached to a static body (or\n    /// not attached to any body) and another collider attached to a static body (or\n    /// not attached to any body).\n    STATIC_STATIC = 0b0000_0000_0010_0000,\n    /// The default active collision types, enabling collisions between a dynamic body\n    /// and another body of any type, but not enabling collisions between two non-dynamic bodies.\n    DEFAULT = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_STATIC,\n    /// Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n    ALL = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_STATIC | KINEMATIC_KINEMATIC | KINEMATIC_STATIC |\n          KINEMATIC_KINEMATIC,\n}\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ColliderHandle = number;\n\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    private rawSet: RawColliderSet; // The Collider won't need to free this.\n    readonly handle: ColliderHandle;\n\n    constructor(rawSet: RawColliderSet, handle: ColliderHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        return VectorOps.fromRaw(this.rawSet.coTranslation(this.handle));\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.coRotation(this.handle));\n    }\n\n    /**\n     * Is this collider a sensor?\n     */\n    public isSensor(): boolean {\n        return this.rawSet.coIsSensor(this.handle);\n    }\n\n    public setSensor(isSensor: boolean) {\n        this.rawSet.coSetSensor(this.handle, isSensor);\n    }\n\n    public setShape(shape: Shape) {\n        let rawShape = shape.intoRaw();\n        this.rawSet.coSetShape(this.handle, rawShape);\n        rawShape.free();\n    }\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number) {\n        this.rawSet.coSetRestitution(this.handle, restitution);\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number) {\n        this.rawSet.coSetFriction(this.handle, friction);\n    }\n\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public frictionCombineRule(): CoefficientCombineRule {\n        return this.rawSet.coFrictionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule) {\n        this.rawSet.coSetFrictionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public restitutionCombineRule(): CoefficientCombineRule {\n        return this.rawSet.coRestitutionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule) {\n        this.rawSet.coSetRestitutionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups) {\n        this.rawSet.coSetCollisionGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups) {\n        this.rawSet.coSetSolverGroups(this.handle, groups);\n    }\n\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    public activeHooks() {\n        this.rawSet.coActiveHooks(this.handle);\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks) {\n        this.rawSet.coSetActiveHooks(this.handle, activeHooks);\n    }\n\n    /**\n     * The events active for this collider.\n     */\n    public activeEvents(): ActiveEvents {\n        return this.rawSet.coActiveEvents(this.handle);\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents) {\n        this.rawSet.coSetActiveEvents(this.handle, activeEvents);\n    }\n\n    /**\n     * Gets the collision types active for this collider.\n     */\n    public activeCollisionTypes(): ActiveCollisionTypes {\n        return this.rawSet.coActiveCollisionTypes(this.handle);\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes) {\n        this.rawSet.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    public setTranslation(tra: Vector) {\n        // #if DIM3\n        this.rawSet.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    public setTranslationWrtParent(tra: Vector) {\n        // #if DIM3\n        this.rawSet.coSetTranslationWrtParent(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotation(rot: Rotation) {\n        this.rawSet.coSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n\n\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotationWrtParent(rot: Rotation) {\n        this.rawSet.coSetRotationWrtParent(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n\n    /**\n     * The type of the shape of this collider.\n     */\n    public shapeType(): ShapeType {\n        return this.rawSet.coShapeType(this.handle);\n    }\n\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     */\n    public halfExtents(): Vector {\n        return VectorOps.fromRaw(this.rawSet.coHalfExtents(this.handle));\n    }\n\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     */\n    public radius(): number {\n        return this.rawSet.coRadius(this.handle);\n    }\n\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     */\n    public roundRadius(): number {\n        return this.rawSet.coRoundRadius(this.handle);\n    }\n\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     */\n    public halfHeight(): number {\n        return this.rawSet.coHalfHeight(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     */\n    public vertices(): Float32Array {\n        return this.rawSet.coVertices(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     */\n    public indices(): Uint32Array {\n        return this.rawSet.coIndices(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     */\n    public heightfieldHeights(): Float32Array {\n        return this.rawSet.coHeightfieldHeights(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     */\n    public heightfieldScale(): Vector {\n        let scale = this.rawSet.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     */\n    public heightfieldNRows(): number {\n        return this.rawSet.coHeightfieldNRows(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     */\n    public heightfieldNCols(): number {\n        return this.rawSet.coHeightfieldNCols(this.handle);\n    }\n\n    // #endif\n\n    /**\n     * The unique integer identifier of the rigid-body this collider is attached to.\n     */\n    public parent(): RigidBodyHandle {\n        return this.rawSet.coParent(this.handle);\n    }\n\n    /**\n     * The friction coefficient of this collider.\n     */\n    public friction(): number {\n        return this.rawSet.coFriction(this.handle);\n    }\n\n    /**\n     * The density of this collider.\n     */\n    public density(): number {\n        return this.rawSet.coDensity(this.handle);\n    }\n\n    /**\n     * The collision groups of this collider.\n     */\n    public collisionGroups(): InteractionGroups {\n        return this.rawSet.coCollisionGroups(this.handle);\n    }\n\n    /**\n     * The solver groups of this collider.\n     */\n    public solverGroups(): InteractionGroups {\n        return this.rawSet.coSolverGroups(this.handle);\n    }\n}\n\n\nexport class ColliderDesc {\n    shape: Shape;\n    useMassProps: boolean;\n    mass: number;\n    centerOfMass: Vector;\n    // #if DIM3\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    // #endif\n    density: number;\n    friction: number;\n    restitution: number;\n    rotation: Rotation;\n    translation: Vector;\n    isSensor: boolean;\n    collisionGroups: InteractionGroups;\n    solverGroups: InteractionGroups;\n    frictionCombineRule: CoefficientCombineRule;\n    restitutionCombineRule: CoefficientCombineRule;\n    activeEvents: ActiveEvents;\n    activeHooks: ActiveHooks;\n    activeCollisionTypes: ActiveCollisionTypes;\n\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape: Shape) {\n        this.shape = shape;\n        this.useMassProps = false;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 0xffff_ffff;\n        this.solverGroups = 0xffff_ffff;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = 0;\n        this.activeHooks = 0;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    public static ball(radius: number): ColliderDesc {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    public static capsule(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    public static segment(a: Vector, b: Vector): ColliderDesc {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    public static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    public static roundTriangle(a: Vector, b: Vector, c: Vector, borderRadius: number): ColliderDesc {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    public static polyline(vertices: Float32Array, indices: Uint32Array): ColliderDesc {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    public static trimesh(vertices: Float32Array, indices: Uint32Array): ColliderDesc {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    public static cuboid(hx: number, hy: number, hz: number): ColliderDesc {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    public static roundCuboid(hx: number, hy: number, hz: number, borderRadius: number): ColliderDesc {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    public static heightfield(nrows: number, ncols: number, heights: Float32Array, scale: Vector): ColliderDesc {\n        const shape = new Heightfield(nrows, ncols, heights, scale);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    public static cylinder(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    public static roundCylinder(halfHeight: number, radius: number, borderRadius: number): ColliderDesc {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    public static cone(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    public static roundCone(halfHeight: number, radius: number, borderRadius: number): ColliderDesc {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    public static convexHull(points: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    public static convexMesh(vertices: Float32Array, indices: Uint32Array): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    public static roundConvexHull(points: Float32Array, borderRadius: number): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    public static roundConvexMesh(vertices: Float32Array, indices: Uint32Array, borderRadius: number): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(vertices, indices, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setTranslation(x: number, y: number, z: number): ColliderDesc {\n        if (typeof x != \"number\" || typeof y != \"number\" || typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setRotation(rot: Rotation): ColliderDesc {\n        this.rotation = rot;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param is - Set to `true` of the collider built is to be a sensor.\n     */\n    public setSensor(is: boolean): ColliderDesc {\n        this.isSensor = is;\n        return this;\n    }\n\n    /**\n     * Sets the density of the collider being built.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    public setDensity(density: number): ColliderDesc {\n        this.useMassProps = false;\n        this.density = density;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setMassProperties(mass: number, centerOfMass: Vector, principalAngularInertia: Vector, angularInertiaLocalFrame: Rotation): ColliderDesc {\n        this.useMassProps = true;\n        this.mass = mass;\n        this.centerOfMass = centerOfMass;\n        this.principalAngularInertia = principalAngularInertia;\n        this.angularInertiaLocalFrame = angularInertiaLocalFrame;\n        return this;\n    }\n    // #endif\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number): ColliderDesc {\n        this.restitution = restitution;\n        return this;\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number): ColliderDesc {\n        this.friction = friction;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups): ColliderDesc {\n        this.collisionGroups = groups;\n        return this;\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups): ColliderDesc {\n        this.solverGroups = groups;\n        return this;\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks): ColliderDesc {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents): ColliderDesc {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes): ColliderDesc {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n}","import {RawEventQueue} from '../raw'\nimport {RigidBodyHandle} from '../dynamics'\nimport {ColliderHandle} from '../geometry'\n\n/// Flags indicating what events are enabled for colliders.\nexport enum ActiveEvents {\n    /// Enable intersection events.\n    INTERSECTION_EVENTS = 0b0001,\n    /// Enable contact events.\n    CONTACT_EVENTS = 0b0010,\n}\n\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    raw: RawEventQueue\n\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain: boolean, raw?: RawEventQueue) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    /**\n     * Applies the given javascript closure on each contact event of this collector, then clear\n     * the internal contact event buffer.\n     *\n     * @param f - JavaScript closure applied to each contact event. The\n     * closure should take three arguments: two integers representing the handles of the colliders\n     * involved in the contact, and a boolean indicating if the contact started (true) or stopped\n     * (false).\n     */\n    public drainContactEvents(f: (handle1: ColliderHandle, handle2: ColliderHandle, started: boolean) => void) {\n        this.raw.drainContactEvents(f)\n    }\n\n    /**\n     * Applies the given javascript closure on each intersection event of this collector, then clear\n     * the internal intersection event buffer.\n     *\n     * @param f - JavaScript closure applied to each intersection event. The\n     * closure should take four arguments: two integers representing the handles of the colliders\n     * involved in the intersection, and a boolean indicating if they started intersecting (true) or\n     * stopped intersecting (false).\n     */\n    public drainIntersectionEvents(f: (handle1: ColliderHandle, handle2: ColliderHandle, intersecting: boolean) => void) {\n        this.raw.drainIntersectionEvents(f)\n    }\n\n    /**\n     * Removes all events contained by this collector\n     */\n    public clear() {\n        this.raw.clear();\n    }\n}","import {RawColliderSet, RawRigidBodySet} from \"../raw\"\nimport {RotationOps, VectorOps} from '../math';\nimport {Collider, ColliderDesc, ColliderHandle} from './collider'\nimport {IslandManager, RigidBody, RigidBodyHandle} from \"../dynamics\";\nimport {RigidBodySet} from \"../dynamics\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    raw: RawColliderSet;\n\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawColliderSet) {\n        this.raw = raw || new RawColliderSet();\n    }\n\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The inteer handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(bodies: RigidBodySet, desc: ColliderDesc, parentHandle: RigidBodyHandle): ColliderHandle {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n\n        let handle = this.raw.createCollider(\n            rawShape,\n            rawTra,\n            rawRot,\n            desc.useMassProps,\n            desc.mass,\n            rawCom,\n            // #if DIM3\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            // #endif\n            desc.density,\n            desc.friction,\n            desc.restitution,\n            desc.frictionCombineRule,\n            desc.restitutionCombineRule,\n            desc.isSensor,\n            desc.collisionGroups,\n            desc.solverGroups,\n            desc.activeCollisionTypes,\n            desc.activeHooks,\n            desc.activeEvents,\n            hasParent,\n            hasParent ? parentHandle : 0,\n            bodies.raw,\n        );\n\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        return handle;\n    }\n\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    public remove(handle: ColliderHandle, islands: IslandManager, bodies: RigidBodySet, wakeUp: boolean) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: ColliderHandle): Collider {\n        if (this.raw.contains(handle)) {\n            return new Collider(this.raw, handle);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * The number of colliders on this set.\n     */\n    public len(): number {\n        return this.raw.len();\n    }\n\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    public contains(handle: ColliderHandle): boolean {\n        return this.raw.contains(handle);\n    }\n\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.forEachColliderHandle((handle) => {\n            f(new Collider(this.raw, handle))\n        })\n    }\n\n    /**\n     * Applies the given closure to the handles of each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachColliderHandle(f: (handle: ColliderHandle) => void) {\n        this.raw.forEachColliderHandle(f)\n    }\n}\n","import {Vector, VectorOps} from \"../math\";\nimport {RawRayColliderIntersection, RawRayColliderToi} from \"../raw\";\nimport {ColliderHandle} from \"./collider\";\n\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * The starting point of the ray.\n     */\n    public origin: Vector\n    /**\n     * The direction of propagation of the ray.\n     */\n    public dir: Vector\n\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin: Vector, dir: Vector) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n\n    public pointAt(t: number): Vector {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        }\n    };\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayColliderIntersection {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    colliderHandle: ColliderHandle\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector\n\n    constructor(colliderHandle: ColliderHandle, toi: number, normal: Vector) {\n        this.colliderHandle = colliderHandle;\n        this.toi = toi;\n        this.normal = normal;\n    }\n\n    public static fromRaw(raw: RawRayColliderIntersection): RayColliderIntersection {\n        if (!raw)\n            return null;\n\n        const result = new RayColliderIntersection(\n            raw.colliderHandle(),\n            raw.toi(),\n            VectorOps.fromRaw(raw.normal())\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    colliderHandle: ColliderHandle\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number\n\n    constructor(colliderHandle: ColliderHandle, toi: number) {\n        this.colliderHandle = colliderHandle;\n        this.toi = toi;\n    }\n\n    public static fromRaw(raw: RawRayColliderToi): RayColliderToi {\n        if (!raw)\n            return null;\n\n        const result = new RayColliderToi(\n            raw.colliderHandle(),\n            raw.toi(),\n        );\n        raw.free();\n        return result;\n    }\n}","import {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawPointColliderProjection} from \"../raw\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class PointColliderProjection {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    colliderHandle: ColliderHandle\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean\n\n    constructor(colliderHandle: ColliderHandle, point: Vector, isInside: boolean) {\n        this.colliderHandle = colliderHandle;\n        this.point = point;\n        this.isInside = isInside;\n    }\n\n    public static fromRaw(raw: RawPointColliderProjection): PointColliderProjection {\n        if (!raw)\n            return null;\n\n        const result = new PointColliderProjection(\n            raw.colliderHandle(),\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside()\n        );\n        raw.free();\n        return result;\n    }\n}","import {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawShapeColliderTOI} from \"../raw\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    colliderHandle: ColliderHandle\n    /**\n     * The time of impact of the two shapes.\n     */\n    toi: number\n    /**\n     * The local-space contact point on the first shape, at\n     * the time of impact.\n     */\n    witness1: Vector\n    /**\n     * The local-space contact point on the second shape, at\n     * the time of impact.\n     */\n    witness2: Vector\n    /**\n     * The local-space normal on the first shape, at\n     * the time of impact.\n     */\n    normal1: Vector\n    /**\n     * The local-space normal on the second shape, at\n     * the time of impact.\n     */\n    normal2: Vector\n\n    constructor(colliderHandle: ColliderHandle, toi: number, witness1: Vector, witness2: Vector, normal1: Vector, normal2: Vector) {\n        this.colliderHandle = colliderHandle;\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(raw: RawShapeColliderTOI): ShapeColliderTOI {\n        if (!raw)\n            return null;\n\n        const result = new ShapeColliderTOI(\n            raw.colliderHandle(),\n            raw.toi(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}","import {RawPhysicsPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {IntegrationParameters, JointSet, RigidBodyHandle, RigidBodySet, CCDSolver, IslandManager} from \"../dynamics\";\nimport {BroadPhase, ColliderHandle, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\nexport class PhysicsPipeline {\n    raw: RawPhysicsPipeline\n\n    public free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawPhysicsPipeline) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n\n    public step(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        joints: JointSet,\n        ccdSolver: CCDSolver,\n        eventQueue?: EventQueue,\n        hooks?: PhysicsHooks,\n    ) {\n        let rawG = VectorOps.intoRaw(gravity);\n\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                joints.raw,\n                ccdSolver.raw,\n                eventQueue.raw,\n                hooks,\n                !!hooks ? hooks.filterContactPair : null,\n                !!hooks ? hooks.filterIntersectionPair : null,\n            );\n        } else {\n            this.raw.step(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                joints.raw,\n                ccdSolver.raw,\n            )\n        }\n\n        rawG.free();\n    }\n}\n","import {RawQueryPipeline, RawRayColliderIntersection} from \"../raw\";\nimport {\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups, PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi, Shape, ShapeColliderTOI\n} from \"../geometry\";\nimport {IslandManager, RigidBodySet} from \"../dynamics\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    raw: RawQueryPipeline\n\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawQueryPipeline) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    public update(islands: IslandManager, bodies: RigidBodySet, colliders: ColliderSet) {\n        this.raw.update(islands.raw, bodies.raw, colliders.raw);\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRay(\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        groups: InteractionGroups\n    ): RayColliderToi | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(this.raw.castRay(\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            groups,\n        ));\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        groups: InteractionGroups\n    ): RayColliderIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(this.raw.castRayAndGetNormal(\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            groups,\n        ));\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        groups: InteractionGroups,\n        callback: (intersect: RayColliderIntersection) => boolean,\n    ) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter: RawRayColliderIntersection) => {\n            return callback(RayColliderIntersection.fromRaw(rawInter));\n        };\n\n        this.raw.intersectionsWithRay(\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            groups,\n            rawCallback,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        colliders: &ColliderSet,\n        shapePos: &Vector,\n        shapeRot: &Rotation,\n        shape: &Shape,\n        groups: InteractionGroups,\n    ): ColliderHandle | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            groups,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        colliders: ColliderSet,\n        point: Vector,\n        solid: boolean,\n        groups: InteractionGroups,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(this.raw.projectPoint(\n            colliders.raw,\n            rawPoint,\n            solid,\n            groups,\n        ));\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        colliders: ColliderSet,\n        point: Vector,\n        groups: InteractionGroups,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawPoint = VectorOps.intoRaw(point);\n\n        this.raw.intersectionsWithPoint(\n            colliders.raw,\n            rawPoint,\n            groups,\n            callback,\n        );\n\n        rawPoint.free();\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        groups: InteractionGroups,\n    ): ShapeColliderTOI | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n\n        let result = ShapeColliderTOI.fromRaw(this.raw.castShape(\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawVel,\n            rawShape,\n            maxToi,\n            groups,\n        ));\n\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        groups: InteractionGroups,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n\n        this.raw.intersectionsWithShape(\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            groups,\n            callback,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}","import {\n    RawSerializationPipeline,\n} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {IntegrationParameters, IslandManager, JointSet, RigidBodySet} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {World} from \"./world\";\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    raw: RawSerializationPipeline\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawSerializationPipeline) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param joints - The joints taking part into the simulation.\n     */\n    public serializeAll(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        joints: JointSet,\n    ): Uint8Array {\n        let rawGra = VectorOps.intoRaw(gravity);\n\n        const res = this.raw.serializeAll(\n            rawGra,\n            integrationParameters.raw,\n            islands.raw,\n            broadPhase.raw,\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            joints.raw,\n        );\n        rawGra.free();\n\n        return res;\n    }\n\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    public deserializeAll(data: Uint8Array): World {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}","import {\n    RawBroadPhase, RawCCDSolver, RawColliderSet,\n    RawDeserializedWorld,\n    RawIntegrationParameters, RawIslandManager,\n    RawJointSet, RawNarrowPhase, RawPhysicsPipeline, RawQueryPipeline,\n    RawRigidBodySet, RawSerializationPipeline,\n} from \"../raw\";\n\nimport {\n    BroadPhase,\n    Collider, ColliderDesc,\n    ColliderHandle,\n    ColliderSet, InteractionGroups,\n    NarrowPhase, PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi, Shape, ShapeColliderTOI, TempContactManifold\n} from \"../geometry\";\nimport {\n    CCDSolver,\n    IntegrationParameters, IslandManager,\n    Joint, JointHandle,\n    JointParams,\n    JointSet,\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodySet\n} from \"../dynamics\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {PhysicsPipeline} from \"./physics_pipeline\";\nimport {QueryPipeline} from \"./query_pipeline\";\nimport {SerializationPipeline} from \"./serialization_pipeline\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    public gravity: Vector\n    integrationParameters: IntegrationParameters\n    islands: IslandManager\n    broadPhase: BroadPhase\n    narrowPhase: NarrowPhase\n    bodies: RigidBodySet\n    colliders: ColliderSet\n    joints: JointSet\n    ccdSolver: CCDSolver\n    queryPipeline: QueryPipeline\n    physicsPipeline: PhysicsPipeline\n    serializationPipeline: SerializationPipeline\n\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    public free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.joints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.joints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n    }\n\n    constructor(\n        gravity: Vector,\n        rawIntegrationParameters?: RawIntegrationParameters,\n        rawIslands?: RawIslandManager,\n        rawBroadPhase?: RawBroadPhase,\n        rawNarrowPhase?: RawNarrowPhase,\n        rawBodies?: RawRigidBodySet,\n        rawColliders?: RawColliderSet,\n        rawJoints?: RawJointSet,\n        rawCCDSolver?: RawCCDSolver,\n        rawQueryPipeline?: RawQueryPipeline,\n        rawPhysicsPipeline?: RawPhysicsPipeline,\n        rawSerializationPipeline?: RawSerializationPipeline\n    ) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(rawIntegrationParameters);\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.joints = new JointSet(rawJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(rawSerializationPipeline);\n    }\n\n    public static fromRaw(raw: RawDeserializedWorld): World {\n        if (!raw)\n            return null;\n\n        return new World(\n            VectorOps.fromRaw(raw.takeGravity()),\n            raw.takeIntegrationParameters(),\n            raw.takeIslandManager(),\n            raw.takeBroadPhase(),\n            raw.takeNarrowPhase(),\n            raw.takeBodies(),\n            raw.takeColliders(),\n            raw.takeJoints(),\n        );\n    }\n\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    public takeSnapshot(): Uint8Array {\n        return this.serializationPipeline.serializeAll(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.joints,\n        );\n    }\n\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    public static restoreSnapshot(data: Uint8Array): World {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    public step(eventQueue?: EventQueue, hooks?: PhysicsHooks) {\n        this.physicsPipeline.step(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.joints,\n            this.ccdSolver,\n            eventQueue,\n            hooks,\n        );\n        this.queryPipeline.update(this.islands, this.bodies, this.colliders);\n    }\n\n    /**\n     * The current simulation timestep.\n     */\n    get timestep(): number {\n        return this.integrationParameters.dt;\n    }\n\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param timestep - The timestep length, in milliseconds.\n     */\n    set timestep(dt: number) {\n        this.integrationParameters.dt = dt;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based force constraint solver can make.\n     */\n    get maxVelocityIterations(): number {\n        return this.integrationParameters.maxVelocityIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations (default: 4).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityIterations(niter: number) {\n        this.integrationParameters.maxVelocityIterations = niter;\n    }\n\n    /**\n     * The maximum position iterations the position-based constraint regularization solver can make.\n     */\n    get maxPositionIterations(): number {\n        return this.integrationParameters.maxPositionIterations;\n    }\n\n    /**\n     * Sets the maximum number of position iterations (default: 1).\n     *\n     * The greater this value is, the less penetrations will be visible after one timestep where\n     * the velocity solver did not converge entirely. Large values will degrade significantly\n     * the performance of the simulation.\n     *\n     * To increase realism of the simulation it is recommended, more efficient, and more effecive,\n     * to increase the number of velocity iterations instead of this number of position iterations.\n     *\n     * @param niter - The new maximum number of position iterations.\n     */\n    set maxPositionIterations(niter: number) {\n        this.integrationParameters.maxPositionIterations = niter;\n    }\n\n    /**\n     * Creates a new rigid-body from the given rigd-body descriptior.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    public createRigidBody(body: RigidBodyDesc): RigidBody {\n        return this.bodies.get(this.bodies.createRigidBody(body));\n    }\n\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parentHandle - The handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(desc: ColliderDesc, parentHandle?: RigidBodyHandle): Collider {\n        return this.colliders.get(this.colliders.createCollider(this.bodies, desc, parentHandle));\n    }\n\n    /**\n     * Creates a new joint from the given joint descriptior.\n     *\n     * @param joint - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     */\n    public createJoint(\n        params: JointParams,\n        parent1: RigidBody,\n        parent2: RigidBody\n    ): Joint {\n        return this.joints.get(\n            this.joints.createJoint(this.bodies, params, parent1.handle, parent2.handle)\n        );\n    }\n\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getRigidBody(handle: RigidBodyHandle): RigidBody {\n        return this.bodies.get(handle);\n    }\n\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    public getCollider(handle: ColliderHandle): Collider {\n        return this.colliders.get(handle);\n    }\n\n    /**\n     * Retrieves a joint from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getJoint(handle: JointHandle): Joint {\n        return this.joints.get(handle);\n    }\n\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    public removeRigidBody(body: RigidBody) {\n        this.bodies.remove(\n            body.handle,\n            this.islands,\n            this.colliders,\n            this.joints,\n        );\n    }\n\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    public removeCollider(collider: Collider, wakeUp: boolean) {\n        this.colliders.remove(\n            collider.handle,\n            this.islands,\n            this.bodies,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Removes the given joint from this physics world.\n     *\n     * @param joint - The joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeJoint(joint: Joint, wakeUp: boolean) {\n        this.joints.remove(\n            joint.handle,\n            this.islands,\n            this.bodies,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.colliders.forEachCollider(f)\n    }\n\n    /**\n     * Applies the given closure to the integer handle of each collider managed by this physics world.\n     *\n     * @param f(handle) - The function to apply to the integer handle of each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachColliderHandle(f: (handle: ColliderHandle) => void) {\n        this.colliders.forEachColliderHandle(f)\n    }\n\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachRigidBody(f)\n    }\n\n    /**\n     * Applies the given closure to the integer handle of each rigid-body managed by this physics world.\n     *\n     * @param f(handle) - The function to apply to the integer handle of each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.bodies.forEachRigidBodyHandle(f)\n    }\n\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n\n    /**\n     * Applies the given closure to the integer handle of each active rigid-body\n     * managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f(handle) - The function to apply to the integer handle of each active rigid-body managed by this\n     *   physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.islands.forEachActiveRigidBodyHandle(f);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        groups: InteractionGroups\n    ): RayColliderToi | null {\n        return this.queryPipeline.castRay(this.colliders, ray, maxToi, solid, groups);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        groups: InteractionGroups\n    ): RayColliderIntersection | null {\n        return this.queryPipeline.castRayAndGetNormal(this.colliders, ray, maxToi, solid, groups);\n    }\n\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        groups: InteractionGroups,\n        callback: (intersect: RayColliderIntersection) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithRay(this.colliders, ray, maxToi, solid, groups, callback)\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        shapePos: &Vector,\n        shapeRot: &Rotation,\n        shape: &Shape,\n        groups: InteractionGroups,\n    ): ColliderHandle | null {\n        return this.queryPipeline.intersectionWithShape(this.colliders, shapePos, shapeRot, shape, groups);\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        point: Vector,\n        solid: boolean,\n        groups: InteractionGroups,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPoint(this.colliders, point, solid, groups);\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        point: Vector,\n        groups: InteractionGroups,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithPoint(this.colliders, point, groups, callback);\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        groups: InteractionGroups,\n    ): ShapeColliderTOI | null {\n        return this.queryPipeline.castShape(this.colliders, shapePos, shapeRot, shapeVel, shape, maxToi, groups);\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        groups: InteractionGroups,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithShape(this.colliders, shapePos, shapeRot, shape, groups, callback);\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(collider1: ColliderHandle, f: (collider2: ColliderHandle) => void) {\n        this.narrowPhase.contactsWith(collider1, f);\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(collider1: ColliderHandle, f: (collider2: ColliderHandle) => void) {\n        this.narrowPhase.intersectionsWith(collider1, f);\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(collider1: ColliderHandle, collider2: ColliderHandle, f: (manifold: TempContactManifold, flipped: boolean) => void) {\n        this.narrowPhase.contactPair(collider1, collider2, f);\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: ColliderHandle, collider2: ColliderHandle): boolean {\n        return this.narrowPhase.intersectionPair(collider1, collider2);\n    }\n\n}\n","import {RigidBodyHandle} from \"../dynamics\";\nimport {ColliderHandle} from \"../geometry\";\n\nexport enum ActiveHooks {\n    FILTER_CONTACT_PAIRS = 0b0001,\n    FILTER_INTERSECTION_PAIRS = 0b0010,\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n}\n\nexport enum SolverFlags {\n    EMPTY = 0b000,\n    COMPUTE_IMPULSE = 0b001,\n}\n\nexport interface PhysicsHooks {\n    /**\n     * Function that determines if contacts computation should happen between two colliders, and how the\n     * constraints solver should behave for these contacts.\n     *\n     * This will only be executed and taken into account if at least one of the involved colliders contains the\n     * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterContactPair(collider1: ColliderHandle, collider2: ColliderHandle, body1: RigidBodyHandle, body2: RigidBodyHandle): SolverFlags | null;\n\n\n    /**\n     * Function that determines if intersection computation should happen between two colliders (where at least\n     * one is a sensor).\n     *\n     * This will only be executed and taken into account if `one of the involved colliders contains the\n     * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterIntersectionPair(collider1: ColliderHandle, collider2: ColliderHandle, body1: RigidBodyHandle, body2: RigidBodyHandle): boolean;\n}","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","// @ts-ignore\nimport wasmBase64 from \"../pkg3d/rapier_wasm3d_bg.wasm\";\nimport wasmInit from \"../pkg3d/rapier_wasm3d\";\nimport base64 from \"base64-js\";\n\n/**\n * Initializes RAPIER.\n * Has to be called and awaited before using any library methods.\n */\nexport async function init() {\n  await wasmInit(base64.toByteArray(wasmBase64 as unknown as string).buffer);\n}\n","import {version as vers} from \"./raw\"\n\nexport function version(): string {\n    return vers();\n}\n\nexport * from './math'\nexport * from './dynamics'\nexport * from './geometry'\nexport * from './pipeline'\nexport * from './init';\n"],"names":["wasm","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","addHeapObject","obj","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","memory","Uint8Array","getStringFromWasm0","ptr","len","subarray","isLikeNone","x","cachegetFloat64Memory0","cachegetInt32Memory0","getInt32Memory0","Int32Array","debugString","val","type","description","name","isArray","debug","i","builtInMatches","exec","toString","call","className","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","stack_pointer","addBorrowedObject","_assertClass","instance","klass","cachegetFloat32Memory0","getFloat32Memory0","Float32Array","getArrayF32FromWasm0","cachegetUint32Memory0","getUint32Memory0","Uint32Array","passArrayF32ToWasm0","malloc","passArray32ToWasm0","handleError","f","args","apply","this","e","__wbindgen_exn_store","Object","freeze","Ball","Fixed","Prismatic","Revolute","Disabled","VelocityBased","AccelerationBased","ForceBased","Dynamic","Static","KinematicPositionBased","KinematicVelocityBased","Cuboid","Capsule","Segment","Polyline","Triangle","TriMesh","HeightField","Compound","ConvexPolyhedron","Cylinder","Cone","RoundCuboid","RoundTriangle","RoundCylinder","RoundCone","RoundConvexPolyhedron","RawBroadPhase","__wrap","create","prototype","__destroy_into_raw","free","__wbg_rawbroadphase_free","constructor","rawbroadphase_new","RawCCDSolver","__wbg_rawccdsolver_free","rawccdsolver_new","RawColliderSet","__wbg_rawcolliderset_free","coTranslation","handle","rawcolliderset_coTranslation","RawVector","coRotation","rawcolliderset_coRotation","RawRotation","coSetTranslation","y","z","rawcolliderset_coSetTranslation","coSetTranslationWrtParent","rawcolliderset_coSetTranslationWrtParent","coSetRotation","w","rawcolliderset_coSetRotation","coSetRotationWrtParent","rawcolliderset_coSetRotationWrtParent","coIsSensor","rawcolliderset_coIsSensor","coShapeType","rawcolliderset_coShapeType","coHalfExtents","rawcolliderset_coHalfExtents","coRadius","retptr","__wbindgen_add_to_stack_pointer","rawcolliderset_coRadius","r0","r1","coHalfHeight","rawcolliderset_coHalfHeight","coRoundRadius","rawcolliderset_coRoundRadius","coVertices","rawcolliderset_coVertices","v0","slice","__wbindgen_free","coIndices","rawcolliderset_coIndices","getArrayU32FromWasm0","coHeightfieldHeights","rawcolliderset_coHeightfieldHeights","coHeightfieldScale","rawcolliderset_coHeightfieldScale","coHeightfieldNRows","rawcolliderset_coHeightfieldNRows","coHeightfieldNCols","rawcolliderset_coHeightfieldNCols","coParent","rawcolliderset_coParent","coFriction","rawcolliderset_coFriction","coDensity","rawcolliderset_coDensity","coCollisionGroups","rawcolliderset_coCollisionGroups","coSolverGroups","rawcolliderset_coSolverGroups","coActiveHooks","rawcolliderset_coActiveHooks","coActiveCollisionTypes","rawcolliderset_coActiveCollisionTypes","coActiveEvents","rawcolliderset_coActiveEvents","coSetSensor","is_sensor","rawcolliderset_coSetSensor","coSetRestitution","restitution","rawcolliderset_coSetRestitution","coSetFriction","friction","rawcolliderset_coSetFriction","coFrictionCombineRule","rawcolliderset_coFrictionCombineRule","coSetFrictionCombineRule","rule","rawcolliderset_coSetFrictionCombineRule","coRestitutionCombineRule","rawcolliderset_coRestitutionCombineRule","coSetRestitutionCombineRule","rawcolliderset_coSetRestitutionCombineRule","coSetCollisionGroups","groups","rawcolliderset_coSetCollisionGroups","coSetSolverGroups","rawcolliderset_coSetSolverGroups","coSetActiveHooks","hooks","rawcolliderset_coSetActiveHooks","coSetActiveEvents","events","rawcolliderset_coSetActiveEvents","coSetActiveCollisionTypes","types","rawcolliderset_coSetActiveCollisionTypes","coSetShape","shape","RawShape","ptr0","rawcolliderset_coSetShape","rawcolliderset_new","rawcolliderset_len","contains","rawcolliderset_contains","createCollider","translation","rotation","useMassProps","mass","centerOfMass","principalAngularInertia","angularInertiaFrame","density","frictionCombineRule","restitutionCombineRule","isSensor","collisionGroups","solverGroups","activeCollisionTypes","activeHooks","activeEvents","hasParent","parent","bodies","RawRigidBodySet","rawcolliderset_createCollider","remove","islands","wakeUp","RawIslandManager","rawcolliderset_remove","isHandleValid","forEachColliderHandle","rawcolliderset_forEachColliderHandle","RawContactManifold","__wbg_rawcontactmanifold_free","normal","rawcontactmanifold_normal","local_n1","rawcontactmanifold_local_n1","local_n2","subshape1","rawcontactmanifold_subshape1","subshape2","num_contacts","rawcontactmanifold_num_contacts","contact_local_p1","rawcontactmanifold_contact_local_p1","contact_local_p2","contact_dist","rawcontactmanifold_contact_dist","contact_fid1","rawcontactmanifold_contact_fid1","contact_fid2","rawcontactmanifold_contact_fid2","contact_impulse","rawcontactmanifold_contact_impulse","contact_tangent_impulse_x","rawcontactmanifold_contact_tangent_impulse_x","contact_tangent_impulse_y","rawcontactmanifold_contact_tangent_impulse_y","num_solver_contacts","rawcontactmanifold_num_solver_contacts","solver_contact_point","rawcontactmanifold_solver_contact_point","solver_contact_dist","rawcontactmanifold_solver_contact_dist","solver_contact_friction","rawcontactmanifold_solver_contact_friction","solver_contact_restitution","rawcontactmanifold_solver_contact_restitution","solver_contact_tangent_velocity","rawcontactmanifold_solver_contact_tangent_velocity","RawContactPair","__wbg_rawcontactpair_free","collider1","rawcontactpair_collider1","collider2","rawcontactpair_collider2","numContactManifolds","rawcontactpair_numContactManifolds","contactManifold","rawcontactpair_contactManifold","RawDeserializedWorld","__wbg_rawdeserializedworld_free","takeGravity","rawdeserializedworld_takeGravity","takeIntegrationParameters","rawdeserializedworld_takeIntegrationParameters","RawIntegrationParameters","takeIslandManager","rawdeserializedworld_takeIslandManager","takeBroadPhase","rawdeserializedworld_takeBroadPhase","takeNarrowPhase","rawdeserializedworld_takeNarrowPhase","RawNarrowPhase","takeBodies","rawdeserializedworld_takeBodies","takeColliders","rawdeserializedworld_takeColliders","takeJoints","rawdeserializedworld_takeJoints","RawJointSet","RawEventQueue","__wbg_raweventqueue_free","autoDrain","raweventqueue_new","drainContactEvents","raweventqueue_drainContactEvents","drainIntersectionEvents","raweventqueue_drainIntersectionEvents","clear","raweventqueue_clear","__wbg_rawintegrationparameters_free","rawintegrationparameters_new","dt","rawintegrationparameters_dt","erp","rawintegrationparameters_erp","jointErp","rawintegrationparameters_jointErp","warmstartCoeff","rawintegrationparameters_warmstartCoeff","allowedLinearError","rawintegrationparameters_allowedLinearError","predictionDistance","rawintegrationparameters_predictionDistance","allowedAngularError","rawintegrationparameters_allowedAngularError","maxLinearCorrection","rawintegrationparameters_maxLinearCorrection","maxAngularCorrection","rawintegrationparameters_maxAngularCorrection","maxVelocityIterations","rawintegrationparameters_maxVelocityIterations","maxPositionIterations","rawintegrationparameters_maxPositionIterations","minIslandSize","rawintegrationparameters_minIslandSize","maxCcdSubsteps","rawintegrationparameters_maxCcdSubsteps","value","rawintegrationparameters_set_dt","rawintegrationparameters_set_erp","rawintegrationparameters_set_jointErp","rawintegrationparameters_set_warmstartCoeff","rawintegrationparameters_set_allowedLinearError","rawintegrationparameters_set_predictionDistance","rawintegrationparameters_set_allowedAngularError","rawintegrationparameters_set_maxLinearCorrection","rawintegrationparameters_set_maxAngularCorrection","rawintegrationparameters_set_maxVelocityIterations","rawintegrationparameters_set_maxPositionIterations","rawintegrationparameters_set_minIslandSize","rawintegrationparameters_set_maxCcdSubsteps","__wbg_rawislandmanager_free","rawislandmanager_new","forEachActiveRigidBodyHandle","rawislandmanager_forEachActiveRigidBodyHandle","RawJointParams","__wbg_rawjointparams_free","ball","anchor1","anchor2","rawjointparams_ball","prismatic","axis1","tangent1","axis2","tangent2","limitsEnabled","limitsMin","limitsMax","rawjointparams_prismatic","fixed","axes1","axes2","rawjointparams_fixed","revolute","rawjointparams_revolute","__wbg_rawjointset_free","jointBodyHandle1","rawjointset_jointBodyHandle1","jointBodyHandle2","rawjointset_jointBodyHandle2","jointType","rawjointset_jointType","jointFrameX1","rawjointset_jointFrameX1","jointFrameX2","rawjointset_jointFrameX2","jointAnchor1","rawjointset_jointAnchor1","jointAnchor2","rawjointset_jointAnchor2","jointAxis1","rawjointset_jointAxis1","jointAxis2","rawjointset_jointAxis2","jointLimitsEnabled","rawjointset_jointLimitsEnabled","jointLimitsMin","rawjointset_jointLimitsMin","jointLimitsMax","rawjointset_jointLimitsMax","jointConfigureMotorModel","model","rawjointset_jointConfigureMotorModel","jointConfigureBallMotorVelocity","vx","vy","vz","factor","rawjointset_jointConfigureBallMotorVelocity","jointConfigureBallMotorPosition","qw","qx","qy","qz","stiffness","damping","rawjointset_jointConfigureBallMotorPosition","jointConfigureBallMotor","rawjointset_jointConfigureBallMotor","jointConfigureUnitMotorVelocity","targetVel","rawjointset_jointConfigureUnitMotorVelocity","jointConfigureUnitMotorPosition","targetPos","rawjointset_jointConfigureUnitMotorPosition","jointConfigureUnitMotor","rawjointset_jointConfigureUnitMotor","rawjointset_new","createJoint","params","parent1","parent2","rawjointset_createJoint","rawjointset_remove","rawjointset_len","rawjointset_contains","forEachJointHandle","rawjointset_forEachJointHandle","__wbg_rawnarrowphase_free","rawnarrowphase_new","contacts_with","handle1","rawnarrowphase_contacts_with","contact_pair","handle2","rawnarrowphase_contact_pair","intersections_with","rawnarrowphase_intersections_with","intersection_pair","rawnarrowphase_intersection_pair","RawPhysicsPipeline","__wbg_rawphysicspipeline_free","rawphysicspipeline_new","step","gravity","integrationParameters","broadPhase","narrowPhase","colliders","joints","ccd_solver","rawphysicspipeline_step","stepWithEvents","eventQueue","hookObject","hookFilterContactPair","hookFilterIntersectionPair","rawphysicspipeline_stepWithEvents","RawPointColliderProjection","__wbg_rawpointcolliderprojection_free","colliderHandle","rawpointcolliderprojection_colliderHandle","point","rawpointcolliderprojection_point","isInside","rawpointcolliderprojection_isInside","RawQueryPipeline","__wbg_rawquerypipeline_free","rawquerypipeline_new","update","rawquerypipeline_update","castRay","rayOrig","rayDir","maxToi","solid","rawquerypipeline_castRay","RawRayColliderToi","castRayAndGetNormal","rawquerypipeline_castRayAndGetNormal","RawRayColliderIntersection","intersectionsWithRay","callback","rawquerypipeline_intersectionsWithRay","intersectionWithShape","shapePos","shapeRot","rawquerypipeline_intersectionWithShape","projectPoint","rawquerypipeline_projectPoint","intersectionsWithPoint","rawquerypipeline_intersectionsWithPoint","castShape","shapeVel","rawquerypipeline_castShape","RawShapeColliderTOI","intersectionsWithShape","rawquerypipeline_intersectionsWithShape","collidersWithAabbIntersectingAabb","aabbCenter","aabbHalfExtents","ptr1","rawquerypipeline_collidersWithAabbIntersectingAabb","__wbg_rawraycolliderintersection_free","rawraycolliderintersection_normal","toi","__wbg_rawraycollidertoi_free","__wbg_rawrigidbodyset_free","rbTranslation","rawrigidbodyset_rbTranslation","rbRotation","rawrigidbodyset_rbRotation","rbSleep","rawrigidbodyset_rbSleep","rbIsSleeping","rawrigidbodyset_rbIsSleeping","rbIsMoving","rawrigidbodyset_rbIsMoving","rbNextTranslation","rawrigidbodyset_rbNextTranslation","rbNextRotation","rawrigidbodyset_rbNextRotation","rbSetTranslation","rawrigidbodyset_rbSetTranslation","rbSetRotation","rawrigidbodyset_rbSetRotation","rbSetLinvel","linvel","rawrigidbodyset_rbSetLinvel","rbSetAngvel","angvel","rawrigidbodyset_rbSetAngvel","rbSetNextKinematicTranslation","rawrigidbodyset_rbSetNextKinematicTranslation","rbSetNextKinematicRotation","rawrigidbodyset_rbSetNextKinematicRotation","rbLinvel","rawrigidbodyset_rbLinvel","rbAngvel","rawrigidbodyset_rbAngvel","rbLockTranslations","locked","wake_up","rawrigidbodyset_rbLockRotations","rbLockRotations","rbRestrictRotations","allow_x","allow_y","allow_z","rawrigidbodyset_rbRestrictRotations","rbDominanceGroup","rawrigidbodyset_rbDominanceGroup","rbSetDominanceGroup","group","rawrigidbodyset_rbSetDominanceGroup","rbEnableCcd","enabled","rawrigidbodyset_rbEnableCcd","rbMass","rawrigidbodyset_rbMass","rbWakeUp","rawrigidbodyset_rbWakeUp","rbIsCcdEnabled","rawrigidbodyset_rbIsCcdEnabled","rbNumColliders","rawrigidbodyset_rbNumColliders","rbCollider","at","rawrigidbodyset_rbCollider","rbBodyType","rawrigidbodyset_rbBodyType","rbIsStatic","rawrigidbodyset_rbIsStatic","rbIsKinematic","rawrigidbodyset_rbIsKinematic","rbIsDynamic","rawrigidbodyset_rbIsDynamic","rbLinearDamping","rawrigidbodyset_rbLinearDamping","rbAngularDamping","rawrigidbodyset_rbAngularDamping","rbSetLinearDamping","rawrigidbodyset_rbSetLinearDamping","rbSetAngularDamping","rawrigidbodyset_rbSetAngularDamping","rbGravityScale","rawrigidbodyset_rbGravityScale","rbSetGravityScale","rawrigidbodyset_rbSetGravityScale","rbApplyForce","force","rawrigidbodyset_rbApplyForce","rbApplyImpulse","impulse","rawrigidbodyset_rbApplyImpulse","rbApplyTorque","torque","rawrigidbodyset_rbApplyTorque","rbApplyTorqueImpulse","torque_impulse","rawrigidbodyset_rbApplyTorqueImpulse","rbApplyForceAtPoint","rawrigidbodyset_rbApplyForceAtPoint","rbApplyImpulseAtPoint","rawrigidbodyset_rbApplyImpulseAtPoint","rawrigidbodyset_new","createRigidBody","gravityScale","translationsEnabled","rotationEnabledX","rotationEnabledY","rotationEnabledZ","linearDamping","angularDamping","rb_type","canSleep","ccdEnabled","dominanceGroup","rawrigidbodyset_createRigidBody","rawrigidbodyset_remove","rawrigidbodyset_len","rawrigidbodyset_contains","forEachRigidBodyHandle","rawrigidbodyset_forEachRigidBodyHandle","__wbg_rawrotation_free","rawrotation_new","identity","rawrotation_identity","rawrotation_y","RawSerializationPipeline","__wbg_rawserializationpipeline_free","rawserializationpipeline_new","serializeAll","rawserializationpipeline_serializeAll","deserializeAll","data","rawserializationpipeline_deserializeAll","__wbg_rawshape_free","cuboid","hx","hy","hz","rawshape_cuboid","roundCuboid","borderRadius","rawshape_roundCuboid","radius","rawshape_ball","capsule","halfHeight","rawshape_capsule","cylinder","rawshape_cylinder","roundCylinder","rawshape_roundCylinder","cone","rawshape_cone","roundCone","rawshape_roundCone","polyline","vertices","indices","__wbindgen_malloc","len0","len1","rawshape_polyline","trimesh","rawshape_trimesh","heightfield","nrows","ncols","heights","scale","rawshape_heightfield","segment","p1","p2","rawshape_segment","triangle","p3","rawshape_triangle","roundTriangle","rawshape_roundTriangle","convexHull","points","rawshape_convexHull","roundConvexHull","rawshape_roundConvexHull","convexMesh","rawshape_convexMesh","roundConvexMesh","rawshape_roundConvexMesh","__wbg_rawshapecollidertoi_free","witness1","witness2","normal1","rawshapecollidertoi_normal1","normal2","__wbg_rawvector_free","zero","rawvector_zero","rawvector_new","rawvector_set_y","xyz","rawvector_xyz","yxz","rawvector_yxz","zxy","rawvector_zxy","xzy","rawvector_xzy","yzx","rawvector_yzx","zyx","rawvector_zyx","async","init","input","URL","imports","wbg","__wbindgen_object_drop_ref","arg0","__wbindgen_number_new","__wbg_rawraycolliderintersection_new","__wbindgen_string_new","arg1","__wbg_now_885ca88fafee0fd1","now","__wbg_newnoargs_1a11e7e8c906996c","Function","__wbg_get_6d26c712aa73c8b2","Reflect","get","arguments","__wbg_call_e91f71ddf1f45cff","__wbindgen_object_clone_ref","__wbg_call_e3c72355d091d5d4","arg2","__wbg_call_c143b19d87139944","arg3","__wbg_call_72facd37dbc97ddb","arg4","__wbg_bind_07839579f523aa89","bind","__wbg_buffer_79a3294266d4e783","__wbg_self_b4546ea7b590539e","self","__wbg_window_c279fea81f426a68","window","__wbg_globalThis_038a6ea0ff17789f","globalThis","__wbg_global_4f93ce884bcee597","global","__wbindgen_is_undefined","__wbg_newwithbyteoffsetandlength_22a36e6023ad3cd0","__wbg_new_945397fb09fec0b8","__wbg_set_223873223acf6d07","__wbg_length_68e13e7bbd918464","__wbindgen_number_get","Float64Array","__wbindgen_boolean_get","v","__wbindgen_debug_string","realloc","mem","offset","code","charCodeAt","passStringToWasm0","__wbindgen_realloc","__wbindgen_throw","__wbindgen_memory","Request","fetch","module","Response","WebAssembly","instantiateStreaming","headers","console","warn","bytes","arrayBuffer","instantiate","Instance","load","exports","__wbindgen_wasm_module","RigidBodyType","VectorOps","Vector3","new","raw","res","RotationOps","Quaternion","rot","JointType","SpringModel","rawSet","RigidBody","enableX","enableY","enableZ","fromRaw","tra","vel","rawVel","intoRaw","t","rawForce","rawImpulse","rawTorque","torqueImpulse","rawTorqueImpulse","rawPoint","status","zeros","angularInertiaLocalFrame","rotationsEnabledX","rotationsEnabledY","rotationsEnabledZ","RigidBodyDesc","TypeError","restrictRotations","can","RigidBodySet","desc","rawTra","rawRot","rawLv","rawCom","rawAv","rawPrincipalInertia","rawInertiaFrame","_this","IntegrationParameters","extendStatics","d","b","setPrototypeOf","__proto__","p","hasOwnProperty","__extends","String","__","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","next","rejected","result","done","then","__generator","body","g","label","sent","trys","ops","verb","throw","return","Symbol","iterator","n","op","pop","CoefficientCombineRule","Joint","UnitJoint","BallJoint","JointParams","frame1","frame2","rawAx1","rawAx2","rawA1","rawA2","rawFra1","rawFra2","limits","rawTa1","rawTa2","JointSet","rawParams","PrismaticJoint","FixedJoint","RevoluteJoint","ShapeType","CCDSolver","IslandManager","BroadPhase","tempManifold","TempContactManifold","NarrowPhase","rawPair","flipped","ActiveCollisionTypes","halfExtents","a","ra","rb","c","rc","Heightfield","rawScale","rawShape","ActiveEvents","Collider","Average","DEFAULT","ColliderDesc","is","ColliderSet","parentHandle","isNaN","origin","dir","Ray","RayColliderIntersection","RayColliderToi","PointColliderProjection","ShapeColliderTOI","PhysicsPipeline","ccdSolver","rawG","filterContactPair","filterIntersectionPair","QueryPipeline","ray","rawOrig","rawDir","rawInter","rawPos","rawCenter","rawHalfExtents","SerializationPipeline","rawGra","World","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawJoints","rawCCDSolver","rawQueryPipeline","rawPhysicsPipeline","rawSerializationPipeline","queryPipeline","physicsPipeline","serializationPipeline","niter","collider","joint","forEachCollider","forEachRigidBody","forEachActiveRigidBody","contactsWith","intersectionsWith","contactPair","intersectionPair","ActiveHooks","SolverFlags","EventQueue","b64","lens","getLens","validLen","placeHoldersLen","tmp","arr","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","join","indexOf","start","end","num","output","wasmInit","base64","toByteArray","_a","version","vers"],"mappings":"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"}